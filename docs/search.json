{
  "articles": [
    {
      "path": "apt_api.html",
      "title": "공공데이터포털 오픈 API를 이용한 데이터 수집",
      "description": "공공데이터포털 오픈 API를 이용한 데이터 수집 로직을 구현해 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n공공데이터포털\n아파트매매 실거래 상세\n자료 수집\nAPI 기본 정보\n요청 변수 (request\nparameter)\n출력 결과\n준비사항\n\n아파트매매\n실거래 상세 자료 조회 프로그램 개발\n요청 URL 생성\n법정동 코드 준비하기\nAPI 호출\nXML 파싱\n다건 처리 로직\n함수의 완성\n함수의 호출\n\n\n\n\n\n\n\n들어가기\n여러분은 NAVER의 오픈 API를 다루어 보았습니다.\n\n그것은 또 다른 오픈 API를 사용할 수 있다는 것을 의미합니다.\n\n이제 여세를 몰아 여러분의 내공이 공공데이터의 수집을 갈망하게 됩니다.\n\n\n공공데이터포털\n공공데이터포털은 정부/지자체의 공공\n데이터 제공을 목적으로 행정안전부에서 운영하는 사이트입니다.\n2022-02-03일 기준으로 68,323건의 데이터를 공개하고 있으며, 오픈\nAPI로는 8,745건을 공개하고 있습니다. 모든 데이터가 질적으로 우수하다고\n단언하기는 어렵지만 몇몇 데이터는 인기가 많습니다.\n데이터를 사용하기 위해서는 회원가입이 필수이며, 오픈 API를\n사용하기 위해서는 활용신청 후 승인을 받아야 합니다.\n아파트매매 실거래 상세 자료\n수집\n우리는 이제 국토교통부의 아파트매매 실거래 상세\n자료를 수집하는 방법을 살펴봅니다. 별도의 아파트매매\n실거래 자료 API가 있으므로 주의해야 합니다.\nAPI 기본 정보\n국토교통부_아파트매매 실거래 상세 자료 상세\n페이지에서 여러 정보를 확인할 수 있습니다.\n출력 포맷이 XML인 API이며, API 서비스 주소는 다음과 같습니다.\n서비스 URL\nhttp://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\n\n요청 변수 (request parameter)\n요청 변수는 다음과 같습니다. 역시 인증을 위한 서비스키가\n필요합니다.\n영문명의 일관성이 떨어집니다. 대문자로만 구성된 영문명과 대소문자로\n구성된 영문명이 혼재합니다. 단어의 결합 방법도 다릅니다. 언더라인(_)\n사용한 것과 캡문자로 구분하는 방법이 섞여있습니다.\n항목명(국문)\n항목명(영문)\n항목크기\n항목구분\n샘플데이터\n항목설명\n서비스키\nServiceKey\n20\n필수\n-\n공공데이터포털에서 받은 인증키\n페이지 번호\npageNo\n4\n옵션\n1\n페이지번호\n한 페이지 결과 수\nnumOfRows\n4\n옵션\n10\n한 페이지 결과 수\n지역코드\nLAWD_CD\n5\n필수\n11110\n지역코드\n계약월\nDEAL_YMD\n6\n필수\n201512\n계약월\n출력 결과\n출력 결과 정보는 너무 실망스럽습니다. 영문명은 일부\n헤더 데이터만 제공하고, 실 데이터는 영문명없이 한글명으로 이루어져\n있습니다. 이것은 한글사랑, 애국의 문제가 아닙니다.\nAPI 프로그래밍을 위해서 변수명(영문명)은 영문으로 정의되어야 합니다.\n변수명은 아스키(ASCII)1 문자 안에서의 알파벳, 숫자와\n르포그램언어에서 지원하는 몇개의 문자로 구성해야 합니다.\n더욱 심각한 문제는 이 정보가 현행화되어 있지 않습니다. 아마도 항목이\n늘어난 것 같은데, 일부 데이터 항목이 이 상세 페이지의 출력결과에\n누락되어 있습니다.\n항목명(국문)\n항목명(영문)\n항목크기\n항목구분\n샘플데이터\n항목설명\n결과코드\nresultCode\n2\n필수\n00\n결과코드\n결과메시지\nresultMsg\n50\n필수\nOK\n결과메시지\n한 페이지 결과 수\nnumOfRows\n4\n필수\n10\n한 페이지 결과 수\n페이지 번호\npageNo\n4\n필수\n1\n페이지번호\n전체 결과 수\ntotalCount\n4\n필수\n3\n전체 결과 수\n거래금액\n거래금액\n40\n필수\n82,500\n거래금액\n건축년도\n건축년도\n4\n필수\n2008\n건축년도\n년\n년\n4\n필수\n2015\n년\n도로명\n도로명\n40\n필수\n사직로8길\n도로명\n도로명건물본번호코드\n도로명건물본번호코드\n5\n필수\n00004\n도로명건물본번호코드\n도로명건물부번호코드\n도로명건물부번호코드\n5\n필수\n00000\n도로명건물부번호코드\n도로명시군구코드\n도로명시군구코드\n5\n필수\n11110\n도로명시군구코드\n도로명일련번호코드\n도로명일련번호코드\n2\n필수\n03\n도로명일련번호코드\n도로명지상지하코드\n도로명지상지하코드\n1\n필수\n0\n도로명지상지하코드\n도로명코드\n도로명코드\n7\n필수\n4100135\n도로명코드\n법정동\n법정동\n40\n필수\n사직동\n법정동\n법정동본번코드\n법정동본번코드\n4\n필수\n0009\n법정동본번코드\n법정동부번코드\n법정동부번코드\n4\n필수\n0000\n법정동부번코드\n법정동시군구코드\n법정동시군구코드\n5\n필수\n11110\n법정동시군구코드\n법정동읍면동코드\n법정동읍면동코드\n5\n필수\n11500\n법정동읍면동코드\n법정동지번코드\n법정동지번코드\n1\n필수\n1\n법정동지번코드\n아파트\n아파트\n40\n필수\n광화문풍림스페이스본(9-0)\n아파트\n월\n월\n2\n필수\n12\n월\n일\n일\n6\n필수\n1~10\n일\n일련번호\n일련번호\n14\n필수\n11110-2203\n일련번호\n전용면적\n전용면적\n20\n필수\n94.51\n전용면적\n지번\n지번\n10\n필수\n9\n지번\n지역코드\n지역코드\n5\n필수\n11110\n지역코드\n층\n층\n4\n필수\n11\n층\n오픈API 상세 화면에서 참고문서인 아파트 매매\n상세자료 조회 기술문서.hwp 파일을 다운로드하면 유용하게 활용할\n수 있습니다.\n\n\n\nFigure 1: 오픈API 상세 화면\n\n\n\n이 파일에는 홈페이지에서 누락된 출력 결과가 기술되어 있습니다. 다음은\n파일에서의 출력결과 정보의 일부입니다.\n\n\n\nFigure 2: 출력결과 정보의 일부\n\n\n\n파일의 정보에는 영문명이 있으나, 이것은 프로그래밍을 위한 변수\n이름으로 사용할 수 없겠습니다. 결국은 API 프로그램 개발자가 변수 이름을\n정의해야할 것 같습니다. 아쉬운 점이 많습니다.\n준비사항\n국토교통부_아파트매매 실거래 상세 자료 상세 오픈\nAPI를 사용하기 위해서는 활용신청을 통해서 미리 승인을\n받아야 합니다.\n승인이 되면 마이페이지에서 개발계정 상세보기에서 다음과 같은 정보를\n확인할 수 있습니다. 일반 인증키 역시 외부로 노출되지 않도록 주의해야\n합니다. 이 서비스는 일일 트래픽이 1000회로 제한되어 있습니다.\n\n\n\nFigure 3: 개발계정 상세보기 화면\n\n\n\n아파트매매\n실거래 상세 자료 조회 프로그램 개발\n요청 URL 생성\nXML 출력 포맷을 사용하기 때문에 다음 요청 URL을 사용합니다.\nhttp://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\nGET 방식의 호출 URL이기 때문에 요청변수 영역을 ?로\n구분하고, 요청 변수들은 &로 구분합니다. 요청변수는\n다음과 같습니다.\nServiceKey : 공공데이터포털에서 받은 인증키\npageNo : 페이지번호\nnumOfRows : 한 페이지 결과 수\nLAWD_CD : 지역코드\nDEAL_YMD : 계약월\n\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n\n\n여기서 한가지 문제가 발생합니다. 서비스를 위해서는 지역코드가\n필요합니다. 그나마 아파트 매매 상세자료 조회\n기술문서.hwp 파일의 요청 메시지 명세 섹션에 “각 지역별\n코드 행정표준코드관리시스템(www.code.go.kr)의 법정동코드 10자리 중 앞\n5자리”라고 설명되어 있습니다.\n법정동 코드 준비하기\n만약에 서울특별시 노원구의 아파트매매 실거래 상세 자료를 조회하기\n위해서는 노원구의 지역코드를 알아야 합니다.\n행정표준코드관리시스템에서 아주 어렵게 법정동 코드를\n조회하는 법정동코드목록조회 화면을 찾았습니다.\n\n\n\nFigure 4: 법정동코드목록조회 화면\n\n\n\n노원구의 법정동코드가 “1135000000”임을 알았습니다. 그리고 API를\n이용하기 위해서는 이 코드의 앞 다섯자리인 “11350”을 사용해야 합니다.\n그런데 매번 특정 지역의 정보를 확인하기 위해서 행정표준코드관리시스템에\n접속해야할까요? 그래서 “법정동 코드 전체자료”를\n다운로드했습니다.\n해당 파일의 압축을 풀고, 데이터 프레임 객체를 만든 다음 R 데이터\n파일과 SQLite DBMS의 테이블에 저장해 두었습니다.\n\n\nlibrary(dplyr)\nfname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\nlegal_divisions <- fname %>%\n  read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n             col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n  mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n  mutate(MAINTAIN = case_when(\n    MAINTAIN == \"존재\" ~ \"Y\",\n    MAINTAIN == \"폐지\" ~ \"N\")\n  ) %>%\n  mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n         MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n  mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n         CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n           stringr::str_remove(\"\\\\s\")) %>%\n  mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n         ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n  filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n\nsave(legal_divisions, file = \"data/legal_divisions.rda\")\n\n\ndb_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\nDBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\n\n\nAPI 호출\n만들어 놓은 url을 XML 패키지의 xmlParse()로 API를 호출합니다. 만약에\n호출 결과가 정상이 아닐 경우에는 에러를 발생시킵니다. 이때, 결과에 대한\n메시지를 보여줍니다.\n\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n\n\nXML 파싱\n조회된 매매정보의 건수를 가져옵니다. 지역코드에 따라 매매정보의\n건수에 대한 편차가 클 것입니다. 도심의 대규모 아파트단지를 포함한 지역은\n매매건수가 많을 것이고, 아파트 수가 적은 지방의 지역은 매매건수가 적을\n것입니다.\n\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n\n\nXML 포멧에서는 item 태그로 개별 검색 결과를 반환합니다. 역시\ngetNodeSet()로 item 노드를 가져다 조작합니다.\nxmlToDataFrame()가 이들 개별 결과들을 데이터 프레임\n객체로 변환합니다.\nget_list() 함수를 정의했습니다. 이 함수의 로직은 한글명을 영문\n변수명으로 변경하는 로직과 필요한 항목만 가져오는 로직이 있습니다.\n\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\n        \"{년}-{str_pad(월, width = 2, pad = '0')}-{str_pad(일, width = 2, pad = '0')}\")\n      ) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  deal_list <- doc %>%\n    get_list()\n\n\n\n다건 처리 로직\n다음은 chunk 사이즈보다 큰 다건의 검색 결과 처리를 위한 로직입니다.\nNAVER 뉴스 검색 로직과 유사합니다.\n\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n\n\n\n함수의 완성\n이상의 로직을 통합해서 아파트매매 실거래 상세 자료를 조회하는 함수를\n다음과 같이 정의하였습니다.\n\n\ntrade_apt <- function(auth_key, LAWD_CD = \"11110\", DEAL_YMD = \"202112\",\n                      chunk_no = 1, chunk = 100, do_done = FALSE) {\n  library(dplyr)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\n        \"{년}-{str_pad(월, width = 2, pad = '0')}-{str_pad(일, width = 2, pad = '0')}\")\n      ) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  deal_list <- doc %>%\n    get_list()\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n함수의 호출\n다음은 2021년 4월 서울 용산구의 아파트매매 실거래 상세 자료를\n조회하는 예제입니다. 실행하면 100건의 결과를 가져옵니다.\n\n\n# Your authorized API keys\nauth_key <- \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11170\", DEAL_YMD = \"200603\")\n\n\n\n다음은 총 312건의 결과를 가져옵니다. 즉, chunk가 300이므로 함수\n내부에서 2번의 API 호출이 이루어집니다.\n\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11170\", DEAL_YMD = \"200603\", chunk = 300,  do_done = TRUE)\n\n\n\n\n미국정보교환표준부호(영어: American\nStandard Code for Information Interchange), 또는 줄여서 ASCII( /ˈæski/,\n아스키)는 영문 알파벳을 사용하는 대표적인 문자 인코딩이다. 아스키는\n컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며,\n대부분의 문자 인코딩이 아스키에 기초를 두고 있다. 출처: https://ko.wikipedia.org/wiki/ASCII↩︎\n",
      "last_modified": "2022-07-08T08:18:51+09:00"
    },
    {
      "path": "control-widget.html",
      "title": "위젯 추가하기",
      "description": "위젯을 이해합니다. **입력 위젯**을 패널에 추가하는 방법을 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n위젯을 아시나요?\n입력 위젯\n\n위젯을 추가한 예제\ntutorial\n입력 위젯 완성하기\ntutorial\nShiny 공식 tutorial\n페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n위젯은\n메신저의 눈과 귀\n입니다.\n의도 파악을 위한 듣는 위젯\n과\n내용의 전달을 위한 말하는 위젯\n으로 구성됩니다.\n\n위젯의 기능과 사용방법을 익히는 것은 말을 익히는 것과 유사합니다. 당신은 문법을 익히고, 어휘를 늘려가야 합니다. 관용어구를 하나 더 익혀야할 수도 있습니다.\n\n\n위젯을 아시나요?\n“위젯(widget)은 컴퓨터 프로그래밍에서 위젯(widget) 또는\n컨트롤(control)은 컴퓨터 사용자가 상호 작용하는 인터페이스 요소입니다.”\n- https://ko.wikipedia.org/wiki/GUI_위젯 중에서\n입력 위젯\nShiny에서는 입력 위젯을 컨트롯 위젯(control widgets)이라 부릅니다.\n즉, 위젯을 통해서 앱을 컨트롤하기 때문입니다. 굳이 입력 위젯이라고\n불렀던 것은 입력된 값을 통해서 기능이 컨트롤되고, 중요한 대부분 컨트롤\n위젯 이름의 접미사가 “Input”이기 때문입니다.\nshiny 패키지의 입력 위젯은 버튼을 포함해서 다음과 같은 종류가\n있습니다.\n\n\nlibrary(shiny)\n\nsetdiff(union(ls(pos = \"package:shiny\", pattern = \"Input$\"), \n      ls(pos = \"package:shiny\", pattern = \"Button$\")),\n      ls(pos = \"package:shiny\", pattern = \"^update\"))\n\n\n [1] \"checkboxGroupInput\"      \"checkboxInput\"          \n [3] \"dateInput\"               \"dateRangeInput\"         \n [5] \"fileInput\"               \"numericInput\"           \n [7] \"passwordInput\"           \"restoreInput\"           \n [9] \"selectInput\"             \"selectizeInput\"         \n[11] \"sliderInput\"             \"snapshotPreprocessInput\"\n[13] \"textAreaInput\"           \"textInput\"              \n[15] \"varSelectInput\"          \"varSelectizeInput\"      \n[17] \"actionButton\"            \"bookmarkButton\"         \n[19] \"downloadButton\"          \"modalButton\"            \n[21] \"submitButton\"           \n\n기본 입력 위젯은 다음 그림과 같습니다.\n기본 입력 위젯위젯을 추가한 예제\n다음 예제는 레이아웃과 패널에 입력 위젯을 출력한 예제입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n\n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = list(\"Percent White\", \n                                 \"Percent Black\",\n                                 \"Percent Hispanic\", \n                                 \"Percent Asian\"),\n                  selected = \"Percent White\"),\n\n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n\n    mainPanel()\n  )\n)\n\n\n\n위의 예제의 결과는 다음과 같습니다.\n입력 위젯들그리고 위 그림에서 selectInput은 이름처럼 여러 값 중에서 하나의 값을\n선택하는 입력 위젯입니다. 다음처럼 마우스를 올려 놓으면 네 개의 값이\n출력되고, 사용자는 하나의 값을 선택하면 됩니다.\nselectInput 위젯tutorial\n입력 위젯 완성하기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해\n보세요. 완성된 입력 위젯의 기능을 확인할 수 있습니다. 여러분은 UI 파트를\n완성하였습니다.\n\n\nlibrary(shiny)\n# Define UI ----\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n\n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = list(\"Percent White\", \n                                 \"Percent Black\",\n                                 \"Percent Hispanic\", \n                                 \"Percent Asian\"),\n                  selected = \"Percent White\"),\n\n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n\n    mainPanel()\n  )\n)\n\n# Define server logic ----\nserver <- function(input, output) {\n\n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 입력 위젯의 종류와 설정하는\n방법을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson3/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, 다양한 입력 위젯과 출력 위젯을 경험해\n보세요.\n\n\nshiny::runExample(\"07_widgets\")\n\n\n\n\n\n\n",
      "last_modified": "2022-07-08T08:18:54+09:00"
    },
    {
      "path": "develop_package.html",
      "title": "koscrap 패키지 개발",
      "description": "몇 가지 Open API를 이용한 데이터 수집 기능을 구현한 R 패키지를 만들어 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\nR 패키지 시나리오\nR 패키지의 구성\n패키지 구성 파일\n파일이름 명명규칙\n\nR 패키지 골격 만들기\nR 패키지 골격 살펴보기\nR 패키지 개발하기\nDESCRIPTION 파일\n수정하기\n소스파일 만들기\n\n패키지 관련 파일의 자동\n생성\nroxygen2\nroxygen2 태그\nroxygen2 태그 기반 자동\n생성\n\nR 데이터 생성\nR 데이터 파일 생성\nR 데이터 도움말 파일\n생성\n\nvignette 작성하기\nvignette 골격 생성하기\nvignette 작성하기\nvignette 빌드하기\n\n개발자의 koscrap 패키지\n설치하기\nR 패키지 설치하기\n\nkoscrap 패키지 사용하기\n사용자의 koscrap 패키지\n설치하기\ndevtools 패키지 설치\nkoscrap 패키지 설치\n\n\n\n\n\n\n\n들어가기\n패키지, 그 범접할 수 없는 아우라!!!\n\n그러나 사실 어렵지 않게 만들 수 있습니다.\n\n시도를 해 보지 않아서 어렵게 느낄뿐 한번 만들고 보면, 이내 두번째 패키지를 만들고 있을 겁니다.\n\n\nR 패키지 시나리오\n앞에서 네이버 오픈 API를 이용해서 뉴스를 검색하는 함수와\n공공데이터포털의 오픈 API를 이용해서 아파트 실거래 상세 정보를 조회하는\n함수를 만들어 보았니다.\n이제 이들 함수를 포함한 R 패키지를 만들어 보려 합니다. 다음의 내용을\n담을 계획입니다.\n함수\n네이버 오픈 API를 이용한, 뉴스 검색 함수\n공공데이터포털의 오픈 API를 이용한, 아파트 실거래 상세 정보 조회\n함수\n\n데이터\n법정동 코드 데이터\n\n소품(Vignettes)1\n두 함수를 사용하는 방법을 소개한 비네트\n\nR 패키지의 구성\n패키지 구성 파일\nDESCRIPTION\n패키지의 기본적인 정보를 담고 있는 메타 파일로 패키지의 버전, 저자,\n종속성 등이 담겨 있습니다. CRAN의 R 패키지 페이지에서는 패키지의 여러\n정보를 제공하는데, 대부분이 DESCRIPTION의 정보로 표현합니다.\nNAMESPACE\n개발하는 패키지가 참조하는 다른 패키지의 객체(함수나 메소드 등),\n개발하는 패키지가 제공하는 객체를 네임스페이스에 등록하기 위한 정보를\n담습니다.\n소스\nR 디렉토리에 프로그램 소스 파일을 담는다. *.R 형식으로\n이름을 정의합니다.\n도움말\nman 디렉토리에 데이터나 함수, 메소드에 대한 도움말\n파일을 담는다. *.Rd 형식으로 이름을 정의합니다.\n소품(vignettes)\nvignettes 디렉토리에 도움말 보다 좀 더 친절한 패키지\n사용 방법을 소개하는 소품 파일을 담습니다. R 마크다운 편집 파일로 *.Rmd\n형식으로 이름을 정의합니다.\n데이터\ndata 디렉토리에 R 데이터 파일을 담습니다. R 데이터\n파일로 *.rda 형식으로 이름을 정의합니다.\n기타 제공 파일\ninst 디렉토리에 패키지를 구성하는 표준 파일이 아니지만\n패키지에 제공할 파일을 넣을 수 있습니다.\n파일이름 명명규칙\nDESCRIPTION, NAMESPACE 파일 이름은 변경이\n불가능합니다. 소스파일과 소품 파일은 이름으로도 그 기능을 유추할 수\n있도록 간결하면서 명확한 이름을 만들어야 합니다. 도움말 파일의 이름은\n도움말을 제공하는 함수 혹은 메소드, 데이터 이름으로 정합니다.\n파일 이름은 절대로 non-ASCII 문자를 포함하면\n안됩니다.\nR 패키지 골격 만들기\nRStudio의 기능을 이용하면 R 패키지의 골격을 쉽게 만들 수\n있습니다.\n패키지의 이름을 koscrap이라고 미리 정합니다.\n“Korean Scraping”을 연상하여 이름을 정했습니다.\nFile > New Project… 메뉴를 선택하면, 다음과 같은 다이얼로그 창이\n뜹니다.\n\n\n\nFigure 1: New Project Wizard 화면\n\n\n\n새로운 디렉토리에 패키지를 만들 것이므로 첫번째, New\nDirectory를 선택합니다.\n\n\n\nFigure 2: R Package 선택 화면\n\n\n\nR 패키지 프로젝트를 만들 것이므로 두번째, R Package를\n선택합니다.\n\n\n\nFigure 3: R Package 정의 화면\n\n\n\n패키지 이름에 “koscrap”을 기입하고, 패키지를 설치할 디렉토리도\n선정합니다. 그리고 “Open in new session”의 체크박스를 선택합니다. 이\n체크 박스는 패키지가 만들어지면 RStudio의 새로운 세션에서 해당 패키지\n프로젝트를 열어 줍니다.\n“Create Project” 버튼을 누르면 RStudio의 새로운 세션이 다음처럼\n열립니다.\n\n\n\nFigure 4: koscrap 패키지 프로젝트 세션 화면\n\n\n\nR 패키지 골격 살펴보기\n만들어진 R 패키지의 골격은 다음과 같습니다\n\n\n\nFigure 5: koscrap 패키지 디렉토리 구조\n\n\n\nhello.R이라는 R 소스 파일과 hello.Rd라는 도움말 파일이 만들어져\n있습니다. 이들 파일의 내용을 살펴보겠습니다.\n\nDESCRIPTION\nPackage: koscrap\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nNAMESPACE\n\n\nexportPattern(\"^[[:alpha:]]+\")\n\n\n\nhello.R\n\n\n# Hello, world!\n#\n# This is an example function named 'hello' \n# which prints 'Hello, world!'.\n#\n# You can learn more about package authoring with RStudio at:\n#\n#   http://r-pkgs.had.co.nz/\n#\n# Some useful keyboard shortcuts for package authoring:\n#\n#   Install Package:           'Cmd + Shift + B'\n#   Check Package:             'Cmd + Shift + E'\n#   Test Package:              'Cmd + Shift + T'\n\nhello <- function() {\n  print(\"Hello, world!\")\n}\n\n\n\nhello.Rd\n\n\\name{hello}\n\\alias{hello}\n\\title{Hello, World!}\n\\usage{\nhello()\n}\n\\description{\nPrints 'Hello, world!'.\n}\n\\examples{\nhello()\n}\n\n\nR 패키지 개발하기\nDESCRIPTION 파일 수정하기\n\nPackage: koscrap\nType: Package \nTitle: Scrap from Public Data Portal & Naver \nVersion: 0.1.1.9000\nDate: 2022-01-31\nAuthors@R: c(\n  person(\"Choonghyun\", \"Ryu\",, \"choonghyun.ryu@gmail.com\", role = c(\"aut\", \"cre\"))\n  )\nDescription: Collect data using Open API from public data portal and scrap NAVER news article information.\nImports: \n    dplyr,\n    httr,\n    XML,\n    stringr,\n    purrr,\n    glue\nAuthor: Choonghyun Ryu [aut, cre]\nMaintainer: Choonghyun Ryu <choonghyun.ryu@gmail.com>\nLicense: GPL-2 | file LICENSE\nEncoding: UTF-8\nLazyData: true\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.1\n\n대표적인 태그의 의미는 다음과 같습니다.\nPackage\n패키지 이름 정의\n\nTitle, Description\n패키지 타이틀과 소개 정의\n\nVersion\n패키지 버전 정의\n0.1.1.9000\n0.1.1: 버전\n9000: 개발버전\n\n\nImports\n패키지의 종속성 정의\n패키지의 기능을 구현하기 위해서 반드시 필요한 패키지로 해당 패키지\n설치시 자동으로 설치됩니다.\n\nAuthor, Maintainer\n패키지의 저자 및 유지보수 관리자\n\nLazyData\n데이터를 사용하기 전까지 메모리에 로드되지 않을지의 여부\ntrue일 경우에 사용전에는 메모리에 로드되지 않음\n\n소스파일 만들기\n다음처럼 두개의 소스 파일을 R 디렉토리에 복사해 넣습니다.\n\nsearch_naver.R\n\n\n#' 네이버 뉴스 검색\n#'\n#' @description 네이버 뉴스 검색 결과를 출력해주는 REST API를 호출하여, 뉴스 정보를 검색합니다.\n#'\n#' @details 네이버에서 발급받은 Client ID, Client Secret는 개인이 발급받은 키를 사용하며,\n#' 유출되어서는 안됩니다.\n#'\n#' @param query character. 검색을 원하는 문자열\n#' @param chunk_no integer. 검색 시작 위치로 최대 1000까지 가능\n#' @param chunk integer. 검색 결과 출력 건수 지정 (1~100)\n#' @param do_done logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n#' 추가로 호출해서 모든 결과를 가져올지의 여부\n#' @param sort character. 정렬 옵션: sim (유사도순), date (날짜순)\n#' @param max_record integer. 최대 조회할 건수. 실제로 검색한 건수는 max_record와 정확히 일치하지 않을 수 있습니다.\n#' chunk의 개수로 데이터를 수집하기 때문에 일반적인 경우에는 max_record보다 같거나  큰 chunk의 배수만큼 데이터를 가져옵니다.\n#' do_done가 FALSE일 경우에는 적용되지 않습니다.\n#' @param client_id character. 애플리케이션 등록 시 발급받은 Client ID\n#' @param client_secret character. 애플리케이션 등록 시 발급받은 Client Secret\n#'\n#' @return data.frame\n#' 변수 목록은 다음과 같음.:\n#' \\itemize{\n#' \\item title : character. 기사의 타이틀\n#' \\item originallink : character. 검색 결과 문서의 제공 언론사 하이퍼텍스트 link\n#' \\item link : character. 검색 결과 문서의 제공 네이버 하이퍼텍스트 link\n#' \\item description : character. 검색 결과 문서의 내용을 요약한 패시지 정보.\n#' 문서 전체의 내용은 link를 따라가면 읽을 수 있음. 패시지에서 검색어와 일치하는 부분은 태그로 감싸져 있음\n#' \\item publish_date : POSIXct. 검색 결과 문서가 네이버에 제공된 시간\n#' \\item title_text : character. 타이틀에서 HTML 태크를 제거한 텍스트\n#' \\item description_text : character. 요약한 패시지 정보에서 HTML 태크를 제거한 텍스트\n#' }\n#'\n#' @examples\n#' \\donttest{\n#' # Your authorized API keys\n#' client_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\n#' client_secret <- \"XXXXXXXXX\"\n#'\n#' search_list <- search_naver(\n#'   \"불평등\", client_id = client_id, client_secret = client_secret\n#' )\n#'\n#' search_list <- search_naver(\n#'   \"불평등\", client_id = client_id, client_secret = client_secret,\n#'   do_done = TRUE, max_record = 350\n#' )\n#'\n#' }\n#'\n#' @import dplyr\n#' @importFrom XML xmlParse getNodeSet xmlValue xmlToDataFrame\n#' @importFrom httr GET add_headers\n#' @importFrom purrr map_df\n#' @importFrom glue glue\n#' @export\n#'\nsearch_naver <- function(query = NULL, chunk = 100, chunk_no = 1,\n                         sort = c(\"date\", \"sim\"), do_done = FALSE,\n                         max_record = 1000L, client_id = NULL,\n                         client_secret = NULL, verbose = TRUE) {\n  if (is.null(query)) {\n    stop(\"검색 키워드인 query를 입력하지 않았습니다.\")\n  }\n\n  if (chunk < 1 & chunk > 100) {\n    stop(\"chunk 요청 변수값이 허용 범위(1~100)인지 확인해 보세요.\")\n  }\n\n  if (chunk_no < 1 & chunk_no > 100) {\n    stop(\"chunk_no 요청 변수값이 허용 범위(1~1000)인지 확인해 보세요.\")\n  }\n\n  sort <- match.arg(sort)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n  }\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  if (verbose) {\n    glue::glue(\"* 검색된 총 기사 건수는 {total_count}건입니다.\\n\\n\") %>%\n      cat()\n\n    glue::glue(\"  - ({chunk}/{min(total_count, max_record)})건 호출을 진행합니다.\\n\\n\") %>%\n      cat()\n  }\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\ntrade_apt.R\n\n\n#' 아파트 실거래 데이터 가져오기\n#'\n#' @description 공공데이터포털에서 REST open API로 아파트 실거래 데이터를 수집합니다.\n#'\n#' @details 공공데이터포털에서 발급받은 API 인증키는 개인이 발급받은 키를 사용하며,\n#' 유출되어서는 안됩니다.\n#'\n#' @param auth_key character. 공공데이터포털에서 발급받은 API 인증키\n#' @param LAWD_CD character. 지역코드. 각 지역별 코드 행정표준코드관리시스템\n#' (www.code.go.kr)의 법정동코드 10자리 중 앞 5자리\n#' @param DEAL_YMD character. 실거래 자료의 계약년월(6자리)\n#' @param chunk_no integer. 페이지번호\n#' @param chunk integer. 한 페이지 결과 수\n#' @param do_done logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n#' 추가로 호출해서 모든 결과를 가져올지의 여부\n#'\n#' @return data.frame\n#' 변수 목록은 다음과 같음.:\n#' \\itemize{\n#' \\item LAWD_CD : character. 지역코드\n#' \\item DEAL_DATE : character. 거래일자\n#' \\item SERIAL : character. 일련번호\n#' \\item BUILD_NM : character. 아파트 이름\n#' \\item FLOOR : integer. 층\n#' \\item BUILD_YEAR : integer. 건축년도\n#' \\item AREA : numeric. 전용면적\n#' \\item AMOUNT : integer. 거래금액\n#' \\item ROAD_CD : character. 도로명코드\n#' \\item ROAD_NM : character. 도로명\n#' \\item BUILD_MAJOR : character. 도로명건물본번호코드\n#' \\item BUILD_MINOR : character. 도로명건물부번호코드\n#' \\item ROAD_SEQ : character. 도로명일련번호코드\n#' \\item BASEMENT_FLAG : character. 도로명지상지하코드\n#' \\item LAND_NO : character. 지번\n#' \\item DONG_NM : character. 법정동\n#' \\item DONG_MAJOR : character. 법정동본번코드\n#' \\item DONG_MINOR : character. 법정동부번코드\n#' \\item EUBMYNDONG_CD : character. 법정동읍면동코드\n#' \\item DONG_LAND_NO : character. 법정동지번코드\n#' \\item DEALER_ADDR : character. 중개사소재지\n#' \\item CANCEL_DEAL : character. 해제여부\n#' \\item CANCEL_DATE : character. 해제사유발생일\n#' }\n#'\n#' @examples\n#' \\donttest{\n#' # Your authorized API keys\n#' auth_key <- \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n#'\n#' result <- trade_apt(auth_key, LAWD_CD = \"11680\", DEAL_YMD = \"202104\")\n#' result <- trade_apt(auth_key, LAWD_CD = \"11680\", DEAL_YMD = \"202104\", do_done = TRUE)\n#'\n#' }\n#'\n#' @import dplyr\n#' @importFrom XML xmlParse getNodeSet xmlValue xmlToDataFrame\n#' @importFrom stringr str_pad\n#' @importFrom purrr map_df\n#' @importFrom glue glue\n#' @export\ntrade_apt <- function(auth_key, LAWD_CD = \"11110\", DEAL_YMD = \"202112\",\n                      chunk_no = 1, chunk = 400, do_done = FALSE) {\n  library(dplyr)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{\n                                  str_pad(일, width = 2, pad = '0')}\")) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  deal_list <- doc %>%\n    get_list()\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n\n패키지 관련 파일의 자동 생성\nroxygen2\nroxygen2 패키지는 패키지를 개발할 때 help page를\n기술하는 파일인 Rd 파일과 NAMESPACE 파일을\n자동으로 작성해줍니다.\n일반적으로 Rd 파일은 패키지 홈 디렉토리의 man 디렉토리에 .Rd,\n.rd 포맷의 이름으로 만듧니다. 그런데 roxygen2 패키지는\n패키지를 정의하는 R 소스 파일에 roxygen 형식으로 스크립트를 작성하면,\n자동으로 Rd 파일을 생성해줍니다.\nNAMESPACE 파일에는 패키지에서 참조하는 다른 패키지나 패키지의\n함수를 지정하는 import 정보 및 패키지의 함수에 접근할\n수 있는 export 정보를 기술합니다.\n다음은 roxygen 형식으로 스크립트를 작성한 R 소스 파일의 예제입다.\n\n\n#' 두 월도 사이의 개월수 구하기\n#' @description 두개의 년월 사이에 몇 개의 개월이 포함되는 지를 구함\n#' @param start_year integer. 시작하는 년도를 나타내는 수치값\n#' @param start_month integer. 시작하는 월을 나타내는 수치값\n#' @param end_year integer. 종료하는 년도를 나타내는 수치값\n#' @param end_month integer. 종료하는 월을 나타내는 수치값\n#' @return 개월수를 나타내는 수치 벡터\n#' @author 유충현\n#' Maintainer: 유충현 <choonghyun.ryu@gmail.com>\n#' @seealso \\code{\\link{get_next_month}}, \\code{\\link{is_indate}}\n#' @examples\n#' get_month_length(2015, 3, 2017, 3)\n#' @export\nget_month_length <- function(start_year, start_month, end_year, end_month) {\n  ifelse(start_month > end_month, 12 + end_month - start_month +\n    (end_year - start_year - 1) * 12 + 1, end_month - start_month +\n    (end_year - start_year) * 12 + 1)\n}\n\n\n\nroxygen 스크립트의 시작은 #'로\n시작합니다. 즉, R 소스 파일에서 #'로 시작하는\n라인은 roxygen2 패키지가 해석하는 라인입니다.\nroxygen2 태그\nroxygen2의 대표적인 태그는 다음과 같습니다.:\n@title : Rd 파일의\n\\title 태그로 기술될 태그\n함수의 타이틀을 기술\n@title을 기술하지\n않으면, 첫 줄의 내용이 \\title 태그로 기술됨\n\n@description\n: Rd 파일의 태그로 기술될 태그\n함수의 상세 설명을 기술\n\n@param : Rd 파일의\n태그 내의\n태그로 기술될 태그\n함수의 인수 이름과 그 내용을 기술\n\n@return : Rd\n파일의 태그로 기술될 태그\n함수가 반환하는 값에 대한 설명을 기술\n\n@author : Rd\n파일의 \\author 태그로 기술될 태그\n함수 개발자 정보를 기술\n\n@seealso : Rd\n파일의 태그로 기술될 태그\n함께 알아두면 유용한 관련 함수를 기술\n\n@examples : Rd\n파일의 태그로 기술될 태그\n함수의 사용 예제를 기술\n\n@export :\nNAMESPACE 파일의 export() 함수로 기술될 태그\nNAMESPACE 파일에서의 export 정보를 기술할지의 여부를 지정\n해당 태그를 기술할 경우만 export 정보를 기술한다.\n\nroxygen2 태그 기반 자동 생성\nroxygen2 패키지의 roxygenise() 함수는 R\n소스 파일의 roxygen2 태그를 해석하여 도움말 파일인 Rd 파일과 NAMESPACE\n파일을 생성합니다. 또한 DESCRIPTION 파일도 업데이트합니다.\n다음 스크립트를 실행하면 R/misc.R 파일을 읽어서 Rd 파일과 NAMESPACE\n파일을 생성하고, DESCRIPTION 파일을 업데이트 합니다.\n\n\nroxygen2::roxygenise()\n\n\n\nRd 파일의 생성\nroxygenise()의 실행으로, 앞에서 만든 “search_naver.R”과 “trade_apt.R”\n파일의 roxygen2 태그는 도움말 파일을 만들어졌습니다. 이 두 개의 도움말\n중에서 “search_naver.Rd”는 다음과 같습니다.\n\n% Generated by roxygen2: do not edit by hand\n% Please edit documentation in R/search_naver.R\n\\name{search_naver}\n\\alias{search_naver}\n\\title{네이버 뉴스 검색}\n\\usage{\nsearch_naver(\n  query = NULL,\n  chunk = 100,\n  chunk_no = 1,\n  sort = c(\"date\", \"sim\"),\n  do_done = FALSE,\n  max_record = 1000L,\n  client_id = NULL,\n  client_secret = NULL,\n  verbose = TRUE\n)\n}\n\\arguments{\n\\item{query}{character. 검색을 원하는 문자열}\n\n\\item{chunk}{integer. 검색 결과 출력 건수 지정 (1~100)}\n\n\\item{chunk_no}{integer. 검색 시작 위치로 최대 1000까지 가능}\n\n\\item{sort}{character. 정렬 옵션: sim (유사도순), date (날짜순)}\n\n\\item{do_done}{logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n추가로 호출해서 모든 결과를 가져올지의 여부}\n\n\\item{max_record}{integer. 최대 조회할 건수. 실제로 검색한 건수는 max_record와 정확히 일치하지 않을 수 있습니다.\nchunk의 개수로 데이터를 수집하기 때문에 일반적인 경우에는 max_record보다 같거나  큰 chunk의 배수만큼 데이터를 가져옵니다.\ndo_done가 FALSE일 경우에는 적용되지 않습니다.}\n\n\\item{client_id}{character. 애플리케이션 등록 시 발급받은 Client ID}\n\n\\item{client_secret}{character. 애플리케이션 등록 시 발급받은 Client Secret}\n}\n\\value{\ndata.frame\n변수 목록은 다음과 같음.:\n\\itemize{\n\\item title : character. 기사의 타이틀\n\\item originallink : character. 검색 결과 문서의 제공 언론사 하이퍼텍스트 link\n\\item link : character. 검색 결과 문서의 제공 네이버 하이퍼텍스트 link\n\\item description : character. 검색 결과 문서의 내용을 요약한 패시지 정보.\n문서 전체의 내용은 link를 따라가면 읽을 수 있음. 패시지에서 검색어와 일치하는 부분은 태그로 감싸져 있음\n\\item publish_date : POSIXct. 검색 결과 문서가 네이버에 제공된 시간\n\\item title_text : character. 타이틀에서 HTML 태크를 제거한 텍스트\n\\item description_text : character. 요약한 패시지 정보에서 HTML 태크를 제거한 텍스트\n}\n}\n\\description{\n네이버 뉴스 검색 결과를 출력해주는 REST API를 호출하여, 뉴스 정보를 검색합니다.\n}\n\\details{\n네이버에서 발급받은 Client ID, Client Secret는 개인이 발급받은 키를 사용하며,\n유출되어서는 안됩니다.\n}\n\\examples{\n\\donttest{\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 350\n)\n\n}\n\n}\n\n그리고 패키지가 Build되면 이 도움말은 다음과 같은 도움말을 제공하게\n됩니다.\n\n\n\nFigure 6: search_naver 함수의 도움말 화면\n\n\n\nNAMESPACE 파일의 생성\nNAMESPACE 파일도 변경되었습니다.\n@export 태그를\n사용한 두 함수는 export()로, 그리고 참조하는 다른 패키지와 함수들은\nimport(), importFrom()로 기술되었습니다.\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(search_naver)\nexport(trade_apt)\nimport(dplyr)\nimportFrom(XML,getNodeSet)\nimportFrom(XML,xmlParse)\nimportFrom(XML,xmlToDataFrame)\nimportFrom(XML,xmlValue)\nimportFrom(glue,glue)\nimportFrom(httr,GET)\nimportFrom(httr,add_headers)\nimportFrom(purrr,map_df)\nimportFrom(stringr,str_pad)\n\n\n\nR 데이터 생성\n아파트 실거래 상세 조회를 위해서 법정동 코드가 필요합니다. 그래서 이\n코드 정보를 패키지에 포함하려 합니다.\nR 데이터 파일 생성\nR 패키지에서 외부 파일을 넣는 디렉토리인 “inst”에 “meta”라는\n디렉토리를 만든 후 법정동 코드 파일인 “법정동코드 전체자료.txt”을 복사해\n넣은 뒤에 다음의 코드를 실행합니다.\n\n\nlibrary(dplyr)\nfname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\nlegal_divisions <- fname %>%\n  read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n             col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n  mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n  mutate(MAINTAIN = case_when(\n    MAINTAIN == \"존재\" ~ \"Y\",\n    MAINTAIN == \"폐지\" ~ \"N\")\n  ) %>%\n  mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n         MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n  mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n         CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n           stringr::str_remove(\"\\\\s\")) %>%\n  mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n         ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n  filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n\nsave(legal_divisions, file = \"data/legal_divisions.rda\")\n\n\ndb_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\nDBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\n\n\n이 코드가 실행되면, “./inst/meta” 경로에 “법정동코드 전체자료.txt”,\n“GISDB.sqlite”가 위치하고 “./data” 경로에 “legal_divisions.rda” 파일이\n위치하게 됩니다.\nR 데이터 도움말 파일 생성\nlegal_divisons.R 파일에 도움말을 위한 roxygen2 태그를 기술하고,\n앞에서 데이터를 만든 코드를 주석으로 보관합니다. 데이터의 도움말을\n생성하는 roxygen2 태그는 함수의 도움말을 생성하는 것과 다소 차이가\n있습니다.\n\n\n#' 행정구역 코드 정보\n#'\n#' @description\n#' 행정표준관리시스템의 법정동코드 전체자료로부터 추출한 광역시도,시군구, 읍면동 레벨의 코드 정보.\n#'\n#' @details\n#' 공공데이터포털에서 Open API로 행정구역 관련 데이터를 수집할 때, 입력 파라미터로 조직 코드를 사용할 경우가 많습니다.\n#' 이때 이 정보를 이용해서 원하는 지역의 정보를 수집할 수 있습니다.\n#'\n#' @format 45953 관측치와 9 변수를 갖는 data.frame. 다음과 같은 변수를 포함합니다.:\n#' \\describe{\n#'   \\item{DIVISION_ID}{charcter. 법정동 코드.}\n#'   \\item{DIVISION_NM}{charcter. 법정동 이름.}\n#'   \\item{MAINTAIN}{logical. 유지여부.}\n#'   \\item{MEGA_CD}{charcter. 광역시도 코드.}\n#'   \\item{MEGA_NM}{charcter. 광역시도 이름.}\n#'   \\item{CTY_CD}{charcter. 시군구 코드.}\n#'   \\item{CTY_NM}{charcter. 시군구 이름.}\n#'   \\item{ADMI_CD}{charcter. 읍면동 코드.}\n#'   \\item{ADMI_NM}{charcter. 읍면동 이름.}\n#' }\n#' @docType data\n#' @keywords datasets\n#' @name legal_divisions\n#' @usage data(legal_divisions)\n#' @source {\n#' \"행정표준관리시스템\" <https://www.code.go.kr/stdcodesrch/codeAllDownloadL.do>\n#' }\nNULL\n\n# library(dplyr)\n# fname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\n# legal_divisions <- fname %>%\n#   read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n#              col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n#   mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n#   mutate(MAINTAIN = case_when(\n#     MAINTAIN == \"존재\" ~ \"Y\",\n#     MAINTAIN == \"폐지\" ~ \"N\")\n#   ) %>%\n#   mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n#          MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n#   mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n#          CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n#            stringr::str_remove(\"\\\\s\")) %>%\n#   mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n#          ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n#   filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n#\n# save(legal_divisions, file = \"data/legal_divisions.rda\")\n#\n#\n# db_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n#\n# con <- DBI::dbConnect(RSQLite::SQLite(), db_name)\n# DBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\n# DBI::dbDisconnect(con)\n\n\n\nvignette 작성하기\nvignette 골격 생성하기\nusethis::use_vignette(“intro”, title = “introduce koscrap”) 명령어를\n통해서 vignette 골격을 생성합니다. 이 명령어는 vignette의 타이틀이\n“introduce koscrap”인 “intro.Rmd”라는 마크다운 문서 템플리트를\n생성합니다. 또한 출력되는 메시지처럼 여러 작업을 수행합니다.\n\n> usethis::use_vignette(\"intro\", title = \"introduce koscrap\")\n✓ Setting active project to '/Users/choonghyunryu/Documents/01_Personal/00_bitr/01_packages/koscrap'\n✓ Adding 'knitr' to Suggests field in DESCRIPTION\n✓ Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n✓ Adding 'inst/doc' to '.gitignore'\n✓ Creating 'vignettes/'\n✓ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n✓ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✓ Writing 'vignettes/intro.Rmd'\n• Modify 'vignettes/intro.Rmd'\n> \n\nvignette 템플리트인 “intro.Rmd”은 다음과 같습니다.\n---\ntitle: \"introduce koscrap\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{introduce koscrap}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup}\nlibrary(koscrap)\n```\n\nvignette 작성하기\n템플리트를 토대로 해서 다음과 같은 vignette을 작성하였습니다.\nvignette에 명령어와 결과를 포함하여 작성한 이유는, API를 호출하기 위한\n클라이언트 아이디, 보안키 등을 노출하지 않기 위함입니다. 만약 실행\n코드만으로 vignette을 작성하려면, 클라이언트 아이디, 보안키 등의\n노출되기 때문입니다.\n---\ntitle: \"introduce koscrap\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{introduce koscrap}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n## koscrap에 대하여\nkoscrap(Korean Scraping)은 공공데이터포털의 아파트실거래 상세 내역과 NAVER의 뉴스검색 데이터를 수집하는 패키지입니다. REST 오픈 API를 이용해서 정해진 데이터를 수집할 수 있습니다.\n\n## koscrap 기능\n현재 구현된 koscrap의 기능을 다음과 같습니다.\n\n* 공공데이터포털의 아파트실거래\n  - trade_apt()\n* NAVER의 뉴스검색 \n  - search_naver()\n\n## 공공데이터포털의 아파트실거래 예제\n서울특별시 노원구의 2021년도 12월의 아파트 거래 내역을 수집합니다.\n\n먼저 공공데이터포털에서 발급받은 서비스키를 기술합니다. 본 예제는 서비스키는 개인의 정보이므로 여기서는 임의의 문자로 형식만 표기합니다.\n\n```{r, eval=FALSE}\nlibrary(\"koscrap\")\nlibrary(\"dplyr\")\n\nauth_key <- \"xxxxxxxxxxxxxxxxxxx\"\n```\n\n패키지에서 제공하는 법정동 코드 데이터인 `legal_divisions`로부터 노원구의 시군구 코드를 가져옵니다. 그리고 `trade_apt()`로 아파트거래정보를 수집합니다.\n\n```{r, eval=FALSE}\nLAWD_CD <- legal_divisions %>% \n  filter(CTY_NM %in% \"노원구\") %>% \n  select(CTY_CD) %>% \n  filter(row_number() == 1) %>% \n  pull()\n\nnowon <- trade_apt(auth_key, \n          LAWD_CD = LAWD_CD, \n          DEAL_YMD = \"202112\")\n\nglimpse(nowon)\n#> Rows: 59\n#> Columns: 24\n#> $ LAWD_CD       <chr> \"11350\", \"11350\", \"11350\", \"11350\", \"11350\", \"11350\", \"1…\n#> $ DEAL_DATE     <glue> \"2021-12-05\", \"2021-12-06\", \"2021-12-07\", \"2021-12-10\",…\n#> $ SERIAL        <chr> \"11350-149\", \"11350-133\", \"11350-150\", \"11350-151\", \"113…\n#> $ DEAL_TYPE     <chr> \"중개거래\", \"중개거래\", \"중개거래\", \"직거래\", \"중개거래\"…\n#> $ BUILD_NM      <chr> \"주공2\", \"한진한화그랑빌\", \"청백3\", \"청백4\", \"주공2\", \"…\n#> $ FLOOR         <int> 4, 24, 13, 14, 12, 2, 15, 9, 9, 12, 14, 19, 15, 8, 16, 1…\n#> $ BUILD_YEAR    <int> 1992, 2002, 1998, 1998, 1992, 2000, 1992, 1987, 1994, 19…\n#> $ AREA          <chr> \"58.65\", \"114.97\", \"39.84\", \"84.54\", \"44.52\", \"84.98\", \"…\n#> $ AMOUNT        <int> 67500, 125000, 42500, 75000, 53800, 84500, 48000, 73600,…\n#> $ ROAD_CD       <chr> \"4130377\", \"3109006\", \"4130332\", \"4130332\", \"4130377\", \"…\n#> $ ROAD_NM       <chr> \"초안산로1길\", \"마들로\", \"월계로45가길\", \"월계로45가길\",…\n#> $ BUILD_MAJOR   <chr> \"00018\", \"00031\", \"00089\", \"00094\", \"00018\", \"00049\", \"0…\n#> $ BUILD_MINOR   <chr> \"00000\", \"00000\", \"00000\", \"00000\", \"00000\", \"00000\", \"0…\n#> $ ROAD_SEQ      <chr> \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"0…\n#> $ BASEMENT_FLAG <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"…\n#> $ LAND_NO       <chr> \"556\", \"18\", \"780\", \"781\", \"556\", \"929\", \"556\", \"12\", \"7…\n#> $ DONG_NM       <chr> \" 월계동\", \" 월계동\", \" 월계동\", \" 월계동\", \" 월계동\", \"…\n#> $ DONG_MAJOR    <chr> \"0556\", \"0018\", \"0780\", \"0781\", \"0556\", \"0929\", \"0556\", …\n#> $ DONG_MINOR    <chr> \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", …\n#> $ EUBMYNDONG_CD <chr> \"10200\", \"10200\", \"10200\", \"10200\", \"10200\", \"10200\", \"1…\n#> $ DONG_LAND_NO  <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"…\n#> $ DEALER_ADDR   <chr> \"서울 강북구, 서울 성북구\", \"서울 노원구\", \"서울 노원구\"…\n#> $ CANCEL_DEAL   <chr> \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"…\n#> $ CANCEL_DATE   <chr> \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"…\n```\n\n노원구에서 12월에 가장 고가로 매매된 아파트의 가격은 13억3천5백만원입니다. 그리고 매매건수는 상계동>중계동>공릉동 순입니다.\n\n```{r, eval=FALSE}\nnowon %>% \n  summarise(max_price = max(AMOUNT))\n#>   max_price\n#> 1    133500\n\nnowon %>% \n  group_by(DONG_NM) %>% \n  tally() %>% \n  arrange(desc(n))\n#> # A tibble: 5 x 2\n#>   DONG_NM       n\n#>   <chr>     <int>\n#> 1 \" 상계동\"    27\n#> 2 \" 중계동\"    11\n#> 3 \" 공릉동\"    10\n#> 4 \" 월계동\"     8\n#> 5 \" 하계동\"     3\n```\n2006년 10월의 성동구의 매매 현황을 수집합니다. chunk의 값을 800으로 지정해서 765건을 수집했습니다. chunk의 기본값은 100으로 100건을 수집합니다.\n\n```{r, eval=FALSE}\nLAWD_CD <- legal_divisions %>% \n  filter(CTY_NM %in% \"성동구\") %>% \n  select(CTY_CD) %>% \n  filter(row_number() == 1) %>% \n  pull()\n\nsungdong <- trade_apt(auth_key, \n                      LAWD_CD = \"11200\", \n                      DEAL_YMD = \"200610\",\n                      chunk = 800)\n\nNROW(sungdong)\n#> [1] 765\n```\n  \n## 네이버 뉴스 검색 예제\n\"불평등\"이라는 키워드로 뉴스현황을 검색합니다.\n\n사용자의 클라이언트 아이디와 보안키를 입력합니다. 사전에 네이버로부터 발급받아야 합니다.\n\n```{r, eval=FALSE}\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n```\n\n총 285,030건의 뉴스가 검색되었고 100건을 수집했습니다.\n\n```{r, eval=FALSE}\ninequality <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n#> * 검색된 총 기사 건수는 285036건입니다.\n#> - (100/285036)건 호출을 진행합니다.\n```\n\n1000건을 수집해 보겠습니다.\n\n```{r, eval=FALSE}\ninequality_1000 <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 1000\n)\n#> * 검색된 총 기사 건수는 285036건입니다.\n#> - (100/1000)건 호출을 진행합니다.\n#> - (200/1000)건 호출을 진행합니다.\n#> - (300/1000)건 호출을 진행합니다.\n#> - (400/1000)건 호출을 진행합니다.\n#> - (500/1000)건 호출을 진행합니다.\n#> - (600/1000)건 호출을 진행합니다.\n#> - (700/1000)건 호출을 진행합니다.\n#> - (800/1000)건 호출을 진행합니다.\n#> - (900/1000)건 호출을 진행합니다.\n#> - (1000/1000)건 호출을 진행합니다.\n```\n\n```{r, eval=FALSE}\nhead(inequality_1000)\n#>                                                                               title\n#> 1                                          이재명 후보, 문화예술 분야 6대 공약 발표\n#> 2                        조영수 이사장 “다른 사람의 관점에서 나를 성찰하게 하는 책”\n#> 3                [D:이슈] 장르물에 녹여낸 한국 사회…넷플릭스 오리지널 장점이자 한계\n#> 4              &quot;기후위기 대응 64개국 중 59위…우물 안 K-대통령 돼선 안 돼&quot;\n#> 5                       [지자체의 SR] 의정부시, 스마트시티 조성 탄력…국비 20억 확보\n#> 6 이재명 &quot;미래산업 핵심은 재생에너지&quot; 윤석열 &quot;데이터·AI가 핵심&quot;\n#>                                                                     originallink\n#> 1 http://www.cine21.com/news/view/?mag_id=99572&utm_source=naver&utm_medium=news\n#> 2                                         http://ch.yes24.com/Article/View/46942\n#> 3                          https://www.dailian.co.kr/news/view/1079823/?sc=Naver\n#> 4                                       https://www.nocutnews.co.kr/news/5700762\n#> 5                       http://www.srtimes.kr/news/articleView.html?idxno=107666\n#> 6                        https://www.eroun.net/news/articleView.html?idxno=27524\n#>                                                                                      link\n#> 1 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=106&oid=140&aid=0000046515\n#> 2                                                  http://ch.yes24.com/Article/View/46942\n#> 3 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=103&oid=119&aid=0002572721\n#> 4 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=102&oid=079&aid=0003604477\n#> 5                                http://www.srtimes.kr/news/articleView.html?idxno=107666\n#> 6                                 https://www.eroun.net/news/articleView.html?idxno=27524\n#>                                                                                                                                                                                                                                                                         description\n#> 1                                                               방식의 영화 제작 지원을 확대하고, 애니메이션 투자펀드를 만들겠다는 것이다. 이 후보는 대기업의 독과점, 계약 관계의 <b>불평등<\/b> 등을 시정해 문화예술 분야에 공정한 생태계를 조성할 수 있도록 노력하겠다고 강조했다.\n#> 2                                                               그리고 글로벌 각국이 갖는 <b>불평등<\/b>에 대한 의문을 해소해주는 책이죠. 『수레바퀴 밑에서』 헤르만 헤세 저 수레바퀴 밑에서 헤르만 헤세 저 | 강태정 역 일신서적출판사 주인공 한스의 방황과 고뇌가 고등학생 시절... \n#> 3                                                              나아가 극한 경쟁에 내몰린 현대인과 개인의 힘으로는 극복하기 힘든 <b>불평등<\/b> 문제 등 작품에 녹아있는 메시지도 ‘오징어 게임’을 한층 새로운 데스 게임 드라마로 보이게 했다. 그러나 국내 시청자들은 ‘오징어 게임’... \n#> 4                                                 그다음에 <b>불평등<\/b> 여러 가지 쭉 나오는데 이 기후위기는 10위 안에도 못 들어갔습니다. ◇이윤상&gt; 기후위기가... 물론 부동산, 일자리, <b>불평등<\/b> 모두 중요하지만 기후위기는 모든 인류를 다 끝내는 거 아닙니까 그래서 이런... \n#> 5                                                            사업 대상지 내 중랑천 약 4Km 구간에 다목적 AI 스마트 폴 및 스마트 게이트 등을 구축해 사물인터넷과 스마트 정보 체계를 연동하고 홍수 등 재난 위험 상황에 대한 즉각 대응체계 마련 및 정보 서비스 <b>불평등<\/b> 환경을... \n#> 6 尹 &quot;핵폐기물 처리기술 고도화될 것&quot; 李 &quot;원전 정략대상 아냐&quot; 심상정 &quot;<b>불평등<\/b> 해소·녹색전환&quot; 안철수... 沈 &quot;<b>불평등<\/b> 해소·녹색전환&quot; 安 &quot;과학기술 주권국가&quot; 강조 토론 중에는 각 후보의 일자리·성장 방안에 대한 철학도... \n#>          publish_date\n#> 1 2022-02-04 15:17:00\n#> 2 2022-02-04 14:56:00\n#> 3 2022-02-04 14:49:00\n#> 4 2022-02-04 14:44:00\n#> 5 2022-02-04 14:42:00\n#> 6 2022-02-04 14:14:00\n#>                                                       title_text\n#> 1                        이재명 후보 문화예술 분야 6대 공약 발표\n#> 2       조영수 이사장 다른 사람의 관점에서 나를 성찰하게 하는 책\n#> 3 D이슈 장르물에 녹여낸 한국 사회넷플릭스 오리지널 장점이자 한계\n#> 4         기후위기 대응 64개국 중 59위우물 안 K대통령 돼선 안 돼\n#> 5        지자체의 SR 의정부시 스마트시티 조성 탄력국비 20억 확보\n#> 6       이재명 미래산업 핵심은 재생에너지 윤석열 데이터AI가 핵심\n#>                                                                                                                                                                                                  description_text\n#> 1    방식의 영화 제작 지원을 확대하고, 애니메이션 투자펀드를 만들겠다는 것이다. 이 후보는 대기업의 독과점, 계약 관계의 불평등 등을 시정해 문화예술 분야에 공정한 생태계를 조성할 수 있도록 노력하겠다고 강조했다.\n#> 2    그리고 글로벌 각국이 갖는 불평등에 대한 의문을 해소해주는 책이죠. 『수레바퀴 밑에서』 헤르만 헤세 저 수레바퀴 밑에서 헤르만 헤세 저 | 강태정 역 일신서적출판사 주인공 한스의 방황과 고뇌가 고등학생 시절... \n#> 3   나아가 극한 경쟁에 내몰린 현대인과 개인의 힘으로는 극복하기 힘든 불평등 문제 등 작품에 녹아있는 메시지도 ‘오징어 게임’을 한층 새로운 데스 게임 드라마로 보이게 했다. 그러나 국내 시청자들은 ‘오징어 게임’... \n#> 4 그다음에 불평등 여러 가지 쭉 나오는데 이 기후위기는 10위 안에도 못 들어갔습니다. ◇이윤상 기후위기가... 물론 부동산, 일자리, 불평등 모두 중요하지만 기후위기는 모든 인류를 다 끝내는 거 아닙니까 그래서 이런... \n#> 5 사업 대상지 내 중랑천 약 4Km 구간에 다목적 AI 스마트 폴 및 스마트 게이트 등을 구축해 사물인터넷과 스마트 정보 체계를 연동하고 홍수 등 재난 위험 상황에 대한 즉각 대응체계 마련 및 정보 서비스 불평등 환경을... \n#> 6         尹 핵폐기물 처리기술 고도화될 것 李 원전 정략대상 아냐 심상정 불평등 해소·녹색전환 안철수... 沈 불평등 해소·녹색전환 安 과학기술 주권국가 강조 토론 중에는 각 후보의 일자리·성장 방안에 대한 철학도...\n```\nvignette 빌드하기\ndevtools::build_vignettes() 명령어를 통해서 vignette을\n빌드합니다.\n\n> devtools::build_vignettes()\nBuilding koscrap vignettes\n--- re-building ‘intro.Rmd’ using rmarkdown\n--- finished re-building ‘intro.Rmd’\n\n✓ Creating 'doc/'\n✓ Adding '^doc$' to '.Rbuildignore'\n✓ Adding 'doc' to '.gitignore'\nMoving intro.html, intro.R to doc/\nCopying intro.Rmd to doc/\n✓ Creating 'Meta/'\n✓ Adding '^Meta$' to '.Rbuildignore'\n✓ Adding 'Meta' to '.gitignore'\nBuilding vignette index\n> \n\n“Meta” 디렉토리는 vignette에 대한 메타정보를 포함하고 있습니다.\n빌드 후 생성된 “doc” 리렉토리는 “inst” 디렉토리 하위\n디렉토리로 이동시켜야 합니다.\n개발자의 koscrap 패키지\n설치하기\n이제 R패키가 얼추 만들어졌습니다. 마지막으로 패키지를 빌드하는 일만\n남았습니다.\nR 패키지 설치하기\n패키지를 설치하기 위해서 RStudio의 “build 탭 메뉴”의 “Install\nand Restart”를 사용합니다.\n\n\n\nFigure 7: R 패키지 설치\n\n\n\nR 패키지 설치하는 과정이 집행된 후, 정상적으로 패키지가 만들어지면\n자동적으로 콘솔 화면에서 library() 함수로 패키지를 로딩합니다.\nkoscrap 패키지 사용하기\nkoscrap 패키지의 도움말을 선택하면, 다음과 같은 화면을 만나게\n됩니다.\n\n\n\nFigure 8: koscrap 도움말 홈페이지\n\n\n\n다음 명령어를 입력하면 vignette 문서를 볼 수 있습니다.\n\n\nvignette(\"intro\", package = \"koscrap\")\n\n\n\n\n\n\nFigure 9: koscrap vignette 화면\n\n\n\n공공데이터포털의 아파트 실거래 상세조회를 수행해 봅니다.\n먼저 사용자의 서비스키를 입력합니다. 여기서는 서비스키의 보안 유지를\n위해서 임의의 문자로 채워 넣었습니다.\n\n\nlibrary(\"koscrap\")\nauth_key <- \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\n\n\n2020년 6월 지역코드가 “11290”인 곳의 거래 정보를 가져옵니다.\nchunk가 1000이므로 한번 호출에 1000건 이내의 정보를\n가져옵니다. 물론 해당 지역의 거래건수 내에서 가져오게 됩니다.\ndo_done이 TRUE인 의미는 만약 해당 지역의 해당원 거래량이\nchunk에서 지정한 건수보다 클 경우에, 함수 내부적으로 추가\n호출하여 전 건을 가져오라는 의미입니다.\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11290\", DEAL_YMD = \"202006\", chunk = 1000, do_done = TRUE)\n\n> head(result)\n  LAWD_CD  DEAL_DATE   SERIAL DEAL_TYPE BUILD_NM FLOOR BUILD_YEAR   AREA AMOUNT ROAD_CD      ROAD_NM\n1   11290 2020-06-01  11290-4               성북     3       1971  37.36  17000 4121350   성북로31길\n2   11290 2020-06-03  11290-4               성북     1       1971  37.36  14500 4121350   성북로31길\n3   11290 2020-06-11  11290-4               성북     2       1971  37.36  15000 4121350   성북로31길\n4   11290 2020-06-15 11290-11           성북좋은     5       2002 113.54  80000 4121353  성북로6가길\n5   11290 2020-06-18  11290-4               성북     1       1971  37.36  16000 4121350   성북로31길\n6   11290 2020-06-22  11290-8               주암     3       1972  48.73  23000 4121349 성북로31가길\n  BUILD_MAJOR BUILD_MINOR ROAD_SEQ BASEMENT_FLAG LAND_NO DONG_NM DONG_MAJOR DONG_MINOR EUBMYNDONG_CD\n1       00040       00012       01             0   348-3  성북동       0348       0003         10100\n2       00040       00012       01             0   348-3  성북동       0348       0003         10100\n3       00040       00012       01             0   348-3  성북동       0348       0003         10100\n4       00023       00000       01             0  179-96  성북동       0179       0096         10100\n5       00040       00012       01             0   348-3  성북동       0348       0003         10100\n6       00005       00000       01             0     286  성북동       0286       0000         10100\n  DONG_LAND_NO DEALER_ADDR CANCEL_DEAL CANCEL_DATE\n1            1                                    \n2            1                                    \n3            1                                    \n4            1                                    \n5            1                                    \n6            1                                     \n\n이상으로 koscrap 패키지의 간단한 사용을 통해서 패키지가 이상없이\n만들어졌음을 파악했습니다.\n사용자의 koscrap 패키지\n설치하기\nkoscrap 패키지는 github의 public repository에 올려 놓았습니다.\ngithub은 CRAN과 더불어 많은 R 패키지를 배포하는 채널이기도 합니다.\nCRAN은 까다로운 조건 때문에 R 패키지를 submit하기 쉽지 않습니다. 어떤\n경우에는 제약을 해결하지 못하는 관계로 github에만 패키지를 등록하는\n경우도 있습니다.\n여기서는 github에 올려 놓은 패키지를 설치하는 방법을 다룹니다.\ndevtools 패키지 설치\n먼저 devtools 패키지를 설치합니다.\n\n\ninstall.packages(\"devtools\")\n\n\n\nkoscrap 패키지 설치\ndevtools 패키지의 install_github() 함수로 koscrap 패키지를\n설치합니다.\nkoscrap 패키지의 리파지토리 URL이 https://github.com/choonghyunryu/koscrap이므로\n뒷 자리의 정보 사용자/리파지토리이름을 기술하려\n설치합니다.\n\n\ndevtools::install_github(\"choonghyunryu/koscrap\")\n\n\n\n\n소품(Vignettes)은 비네트라고\n발음합니다. 패키지의 기능을 소개하는 짧은 문서를 의미합니다. 함수의\n도움말보다는 규모가 큽니다.↩︎\n",
      "last_modified": "2022-07-08T08:18:59+09:00"
    },
    {
      "path": "index.html",
      "title": "미트업 개요",
      "description": "본 미트업은 **Shiny 개념의 이해**를 돕고, 텍스트 데이터를 수집하고 분석을 수행하는 기능의 **어플리케이션을 공유**하여, **Shiny 앱 개발 여정의 디딤돌**을 놓는 것을 목적으로 합니다. \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n프로그램 개요\n발표자\n미트업 내용\n사전 준비 작업\n네이버 검색\nAPI 이용을 위해 애플리케이션 등록\n\n\n프로그램 개요\n주제:\n시민 데이터 과학 (통계/인공지능), 이광춘\nShiny로 네이버 뉴스 검색하기, 유충현\n\n일시:\n2022년 7월 9일 (토) 10:00 ~ 12:30\n\n장소:\n성균관대학교 퇴계인문관\n\n주최:\nSeoul R Meetup Group\n\n발표자\n유충현:\n현) 한국R사용자회 대표\n현) 한화생명 Data Analytics팀 부장\n\n미트업 내용\nShiny 애플리케이션 개발의 ABC\n아젠다\nShiny 애플리케이션의 이해\n간단한 애플리케이션 개발하기\n\n목적\nShiny 앱의 동작을 이해하고, 간단한 어플리케이션 개발을 위한 자신감\n갖기\n네이버 뉴스 수집과 간단한 텍스트 분석 수행하기\n\n\n사전 준비 작업\n네이버 검색 API\n이용을 위해 애플리케이션 등록\n네이버 회원가입과 개발자센터 접속\n네이버\n개발자센터 접속\n\n애플리케이션등록 신청\n애플리케이션 등록 화면 이동 후,\n사용 API로 검색 선택 후\n비로그인 오픈 API 서비스 환경으로 WEB 설정 선택 후\n등록하기\n\nkosacap 패키지의 설치\n공공데이터 및 네이버 뉴스 스크랩하는 패키지\n설치\nremotes::install_github(“choonghyunryu/koscrap”)\n\n\n\n\n\n",
      "last_modified": "2022-07-08T08:18:59+09:00"
    },
    {
      "path": "introduce_shiny.html",
      "title": "Shiny 아키텍처 이해",
      "description": "Shiny 아키텍처를 이해합니다. **UI**, **server**, **입력 위젯(input widget)**, **출력 위젯(output widget)**, **렌더링(Rendering)** 정도는 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\nShiny 아키텍처\nUI와 Server의 상호작용\nUI와 server의 상호작용\n예시\nUI와 server의 상호작용\n표준화\n\nShiny 첫 예제\n히스토그램 그리기 예제\n예제 실행해 보기\n\ntutorial\nShiny 공식 tutorial\n페이지\n\n\n\n\n\n\n\n들어가기\n본 핸즈온(튜토리얼)은\nShiny를 이해하려는 대상의 OJT를 염두로\n작성되었습니다. 초심자 대상이기 때문에, Shiny의 ABC만   \n     다룹니다. 그 이상의 학습을 원하는 분들은\nResouces\n페이지를 참고하십시요.\n\n학습 내용은\nShiny in seven lessons\n(\nhttps://shiny.rstudio.com/tutorial/\n) 을 참조하여 작성하였습니다.\n\n\nShiny 아키텍처\nUI와 Server의 상호작용\nUI와 Server의 상호작용UI : 사용자 인터페이스(User Interface) 영역으로 입력\n위젯(input widget)을 통해 사용자가 의도하는 파라미터(인수)를 server에\n전달합니다.\nserver : 입력 위젯의 변화를 감지하여, 미리 정의된\n작업을 수행한 후 그 결과를 출력 위젯(output widget)에\n렌더링하여(rendering) 사용자에게 전달합니다.\nUI와 server의 상호작용 예시\nUI와 Server의 상호작용 예시sliderInput 위젯은 사용자 입력을 기다리고,\n입력 위젯(input widget)은 사용자의 입력을 대기\n\n입력을 인지한 후, sliderInput 위젯과 연결된 renderPlot() 함수를 호출\n위젯이 변경되면 변경된 위젯이 포함된 렌더링 함수가 자동\n호출됩니다.\n\nrenderPlot() 함수는 sliderInput 위젯 값만큼의 막대가 포함된\n히스토그램을 그리고,\n렌더링 함수가 실행됩니다.\n\n히스토그램은 출력 위젯(Output widget)인 plotOutput에\n렌더링(그려짐)됩니다.\n출력 위젯에 렌더링된 결과가 반영됩니다.\n\nUI와 server의 상호작용\n표준화\nUI와 server의 상호작용을 shiny 스크립트 관점에서 표준화해 봅니다.\n위젯들은 개별 위젯을 인식하도록 아이디를 부여해야 합니다.\n입력 위젯은 inputId,\n출력 위젯은 outputId\n\n입력 위젯의 이름은 “기능명 + Input” 포맷으로\n정의됩니다.\nsliderInput = slider + Input,\n즉, 슬라이더로 사용자 입력을 받아서 서버로 전달하는\n위젯\n\n출력 위젯의 이름은 “기능명 + Output” 포맷으로\n정의됩니다.\nplotOutput = plot + Output,\n즉, 시각화된 R 플롯을 출력하는 위젯\n\n렌더링 함수 이름은 “render + 기능명” 포맷으로\n정의됩니다.\nrenderPlot = render + Plot,\n즉, 플롯으로 렌더링하는(플롯을 그리는) 함수\n\nShiny 첫 예제\n히스토그램 그리기 예제\nUI와 Server의 상호작용 예시를 구현한 shiny 프로그램은 다음과\n같습니다.\n눈으로 한번 쭉 훑어보세요. 이해할 것 같으면서도 어려운 겁니다.\n\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n\n    output$distPlot <- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    <- faithful[, 2]\n        bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n\n예제 실행해 보기\n아키텍처를 이해하려는 목적으로 결과를 보고 프로그램도 살펴\n보세요.\n\n\nshiny::runExample(\"01_hello\")\n\n\n\ntutorial\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 앱을 실행시키는 방법을\n숙지하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson1/\n\n\n\n",
      "last_modified": "2022-07-08T08:19:01+09:00"
    },
    {
      "path": "news_app.html",
      "title": "네이버 뉴스 검색 애플리케이션",
      "description": "간단한 애플리케이션을 만들어 봅니다. **koscrap** 패키지를 이용해서 **네이버 뉴스 검색 애플리케이션**을 만듭니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n애플리케이션 설계\n기능 설계\n사용자 인터페이스 설계\n\n애플리케이션 코드\nUI Side\nServer Side\nGlobal Environments\n사용 패키지 및\n애플리케이션 호출\n\n애플리케이션 실행\n애플리케이션 실행 화면\n뉴스링크 원문 조회하기\n뉴스 요약 정보의 시각화\n\n\n\n\n\n\n\n들어가기\n공격이 최선의 방어라는 격투기 격언이 있습니다. Shiny의 경우는\n실제로 애플리케이션을 개발해 보는 것이 최선의 학습\n입니다.\n\n간단하지만, 유용한 애플리케이션을 만들어 볼까요? 걱정할 필요 없습니다. 천천히 따라오세요\n\n\n애플리케이션 설계\n기능 설계\n네이버 뉴스 검색 애플리케이션의 기능은 다음과 같이 정의합니다.\n입력 기능\n사용자 인증을 위한 Client ID, Client Secret 입력\n검색하려는 뉴스 키워드 입력\n정렬 옵션 선택\n날짜순 정렬\n유사도순 정렬\n\n검색건수 입력\n\n출력 기능\n검색 뉴스 테이블 출력\n타이틀\n뉴스내용 요약\n뉴스 게시시간\n뉴스 링크\n하이퍼링크를 걸어서, 클릭하면 해당 브라우저 창을 열어 뉴스화면\n이동\n\n\n\n시각화 출력 기능\n입력기능\n상위 최대 돗수 제외 건\n포함할 워드의 최소 돗수\n플롯의 배경색\n\n검색 뉴스들 전체의 워드클라우드 출력\n\n사용자 인터페이스 설계\n페이지\nnavbarPage\n\n레이아웃\nsidebarLayout\n\n패널\nsidebarPanel\n입력 위젯 위치\n\nmainPanel\n출력 위젯 위치\n\n\n입력 위젯\ntextInput\nClient ID, Client Secret, 검색 키워드\n\nradioButtons\n정렬 옵션 선택\n\nsliderInput\n검색건수\n\nactionButton\n뉴스 검색 버튼\n\n\n출력 위젯\nreactable\n검색 결과 출력\n\n\n시각화 입력 위젯\nnumericInput\n상위 최대 돗수 제외 건 선택\n\nnumericInput\n포함할 워드의 최소 돗수 선택\n\ncolourInput\n배경색상 선택\n\n\n시각화 출력 위젯\nwordcloud2Output\n검색 결과 출력\n\n\n애플리케이션 코드\nUI Side\nui.R\n\n\nnavbarPage(\n  \"네이버 뉴스 검색 애플리케이션\",\n  tabPanel(\n    \"뉴스 검색하기\",\n    sidebarLayout(\n      sidebarPanel(\n        textInput(\"client_id\", \n                  label = h4(\"Client ID:\"), \n                  value = client_id),\n        textInput(\"client_secret\", \n                  label = h4(\"Client Secret:\"), \n                  value = client_secret),            \n        textInput(\"keyword\", \n                  label = h4(\"검색 키워드:\"), \n                  value = \"\"),\n        radioButtons(\"sort\", label = h4(\"정렬 옵션:\"),\n                     choices = list(\"날짜순\" = \"date\", \"유사도순\" = \"sim\"), \n                     selected = \"date\"),           \n        sliderInput(\"max_record\", label = h4(\"검색 건수:\"), min = 0,\n                    max = 500, value = 100, step = 100),\n        actionButton(\"search_keyword\", label = \"뉴스 검색\", \n                     icon = icon(\"newspaper\")),\n        width = 3\n      ),\n      # Reactable에 검색 결과 리스트업\n      mainPanel(\n        reactableOutput(\"news_list\"),\n        width = 9\n      )\n    )\n  ),\n  \n  tabPanel(\n    \"워드 클라우드\",\n    sidebarLayout(\n      sidebarPanel(\n        numericInput(\"remove_n\", \n                     label = h4(\"상위 최대 돗수 제외 건:\"), \n                     value = 5, min = 0\n        ),\n        numericInput(\"min_freq\", \n                     label = h4(\"포함할 워드의 최소 돗수:\"), \n                     value = 5, min = 1\n        ),          \n        colourInput(\"col_bg\", \n                    label = h4(\"배경 색상:\"), \n                    value = \"white\"),\n        width = 3\n      ),\n      # 검색 결과 전체의 워드클라우드\n      mainPanel(\n        wordcloud2Output(\"cloud\", height = \"600px\"),\n        width = 9\n      )\n    ) \n  )\n)\n\n\n\nServer Side\nserver.R\n\n\nfunction(input, output, session) {\n    newsList <- reactiveValues(\n      list = data.frame(\n        title = character(0),\n        description = character(0),\n        publish_date = character(0),\n        link = character(0),\n        stringsAsFactors = FALSE\n      ) %>% \n        reactable(\n          defaultColDef = colDef(\n            align = \"left\"\n          ),\n          columns = list(\n            title = colDef(\n              name = \"타이틀\",\n              width = 250,\n            ),\n            description = colDef(name = \"뉴스내용 요약\"),\n            publish_date = colDef(\n              name = \"뉴스 계시시간\",\n              width = 150,\n            ),\n            link = colDef(\n              name = \"뉴스 링크\",\n              width = 250,\n              html = TRUE,\n              cell = function(url) {\n                htmltools::tags$a(href = as.character(url), target = \"_blank\", as.character(url))\n              }\n            )    \n          ),\n          showPageSizeOptions = TRUE,\n          pageSizeOptions = c(5, 10, 15), \n          defaultPageSize = 5,\n          bordered = TRUE,\n          highlight = TRUE\n        )    \n    )\n    \n    output$news_list <- renderReactable({\n      newsList$list <-scraped_news() %>%\n        mutate(title = title_text) %>%\n        mutate(description = description_text) %>%\n        mutate(publish_date = stringr::str_remove_all(publish_date,\n                                                      \"[[:alpha:]]\")) %>%\n        select(title, description, publish_date, link) %>% \n        reactable(\n          defaultColDef = colDef(\n            align = \"left\"\n          ),\n          columns = list(\n            title = colDef(\n              name = \"타이틀\",\n              width = 250,\n            ),\n            description = colDef(name = \"뉴스내용 요약\"),\n            publish_date = colDef(\n              name = \"뉴스 계시시간\",\n              width = 150,\n            ),\n            link = colDef(\n              name = \"뉴스 링크\",\n              width = 250,\n              html = TRUE,\n              cell = function(url) {\n                htmltools::tags$a(href = as.character(url), target = \"_blank\", as.character(url))\n              }\n            )    \n          ),\n          showPageSizeOptions = TRUE,\n          pageSizeOptions = c(5, 10, 15), \n          defaultPageSize = 5,\n          bordered = TRUE,\n          highlight = TRUE\n        )\n    })\n    \n    scraped_news <- eventReactive(input$search_keyword, {\n      # 3개의 텍스트는 반드시 입력해야 함\n      req(input$keyword)\n      req(input$client_id)\n      req(input$client_secret)\n      \n      write_api_key(input$client_id, input$client_secret)\n      \n      koscrap::search_naver(\n        query = input$keyword,\n        sort  = input$sort,\n        chunk = min(input$max_record, 100),\n        max_record = input$max_record,\n        do_done = TRUE,\n        client_id = input$client_id,\n        client_secret = input$client_secret)\n      })\n  \n  output$cloud <- renderWordcloud2({\n    data <- scraped_news()\n    \n    create_wordcloud(\n      data,\n      remove_n = input$remove_n,\n      min_freq = input$min_freq,\n      background = input$col_bg\n    )\n  })\n}\n\n\n\nGlobal Environments\nglobal.R\n\n\n# attach packages\nlibrary(\"shiny\")\nlibrary(\"dplyr\")\nlibrary(\"koscrap\")\nlibrary(\"reactable\")\nlibrary(\"htmltools\")\nlibrary(\"tidytext\")\nlibrary(\"wordcloud2\")\nlibrary(\"colourpicker\")\n\n# Initialize global environments\nwrite_api_key <- function(client_id = NULL, client_secret = NULL) {\n  if (is.null(client_id)) {\n    return()\n  } else {\n    client_info <- glue::glue(\"{client_id}:{client_secret}\") %>%\n      charToRaw() %>%\n      base64enc::base64encode()\n\n    write(client_info, file = \".api_key.info\")\n  }\n}\n\nget_api_key <- function(client_info) {\n  client_info <- rawToChar(base64enc::base64decode(client_info)) %>%\n    strsplit(\":\") %>%\n    unlist()\n\n  client_id <- client_info[1]\n  client_secret <- client_info[2]\n\n  list(client_id = client_id, client_secret = client_secret)\n}\n\noptions(api.key.file = TRUE)\n\nclient_id <- \"\"\nclient_secret <- \"\"\n\nif (getOption(\"api.key.file\")) {\n  if (grepl(\"scrap_app\", getwd()) && file.exists(\".api_key.info\")) {\n    client_info <- scan(file = \".api_key.info\", what = \"character\")\n\n    client_info <- get_api_key(client_info)\n    \n    client_id <- client_info$client_id\n    client_secret <- client_info$client_secret    \n  } else {\n    options(api.key.file = FALSE)\n  }\n}\n\n# create UDF\ncreate_wordcloud <- function(data, remove_n = 5, min_freq = 5, background = \"white\") {\n  data %>% \n    filter(nchar(description_text) > 0) %>%   \n    unnest_tokens(noun, description_text, bitTA::morpho_mecab, type = \"noun\") %>% \n    group_by(noun) %>% \n    count() %>% \n    arrange(desc(n)) %>%     \n    ungroup() %>%\n    filter(n >= min_freq) %>% \n    filter(row_number() > remove_n) %>% \n    wordcloud2::wordcloud2(backgroundColor = background, \n                           fontFamily = \"NamumSquare\")\n}\n\n\n\n사용 패키지 및 애플리케이션\n호출\n\n\n# Run the application \nshinyApp()\n\n\n\n애플리케이션 실행\n애플리케이션 실행 화면\n애플리케이션을 실행하면 다음과 같의 화면을 얻을 수 있습니다.\n네이버 뉴스 검색\n애플리케이션뉴스링크 원문 조회하기\n네번째 컬럼인 뉴스링크는 뉴스 원문의 URL 정보입니다. 이 URL을\n클릭하면, 뉴스의 원문을 읽을 수 있습니다. 다음은 특정 페이지의 뉴스를\n링크를 클릭하여 열린 웹 페이지입니다. 네이버 뉴스 검색 애플리케이션에서\n불평등이라는 키워드로 검색하였기 때문에,\n불평등이란 단어를 검색하였더니 1개 단어가\n매칭되었습니다.\n네이버 뉴스 링크의 뉴스 원문뉴스 요약 정보의 시각화\n수집한 전체 뉴스 데이터 중에서 뉴스 요약을 집계합니다. 워드\n클라우드를 그려 어떤 단어들이 발화되는지 살펴봅니다.\n다음은 워드클라우드 탭을 클릭하여 열린 웹 페이지입니다.\n불평등이라는 키워드로 검색된 기사들에서 어떤 단어들이\n발화되는지 살펴봅니다.\n네이버 뉴스 요약정보의\n워드클라우드\n\n\n",
      "last_modified": "2022-07-08T08:19:07+09:00"
    },
    {
      "path": "open_api.html",
      "title": "네이버 오픈 API를 이용한 데이터 수집",
      "description": "네이버 오픈 API를 이용한 데이터 수집 로직을 구현해 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n오픈 API\n대상 API\n네이버 뉴스 검색\nAPI 기본 정보\n요청 변수 (request\nparameter)\n출력 결과\n준비사항\n\n네이버 뉴스 검색 프로그램\n개발\n요청 URL 생성\nAPI 호출\nXML 파싱\n다건 처리 로직\n함수의 완성\n함수의 호출\n\n\n\n\n\n\n\n들어가기\n공공 데이터 및 기업의 인터넷 서비스의 다수가 오픈 API를 통해서 관련 데이터를 제공합니다.\n\n이제는 데이터 수집을 위해서 오픈 API를 이용할 수 있는 기술을 습득해야 합니다.\n\n이제 여러분은 NAVER의 오픈 API를 다룰 수 있게 됩니다.\n\n\n오픈 API\n오픈 API(Open Application Programming Interface,\nOpen API, 공개 API) 또는 공개 API는 개발자라면 누구나\n사용할 수 있도록 공개된 API를 말하며, 개발자에게 사유 응용 소프트웨어나\n웹 서비스의 프로그래밍 적인 권한을 제공합니다.1\n\n\n\n\n수년 전만해도 공동 데이터의 수집과 NAVER 웹 페이지의 데이터를\n수집하기 위해서는 웹 페이지를 핸들링하는 기술을 통해서 데이터를 Scraping\n해야 했습니다. 그러나 이제는 해당 기관과 업체에서 오픈 API를 제공하기\n때문에, 합법적인 방법으로 원하는 데이터를 수집할 수 있는 세상이\n되었습니다.\n대상 API\n네이버 뉴스 검색\n네이버\n\n아파트 실거래 데이터 가져오기\n공공 데이터 포털\n\n네이버 뉴스 검색\n네이버 뉴스 검색 결과를 출력해주는 REST API를 이용해서 뉴스 데이터를\n수집합니다. Documents > 서비스 API > 검색 > 뉴스에 해당\nAPI에 대한 스팩이 설명되어 있습니다.\nAPI 기본 정보\n다음과 같은 두 가지의 API가 있습니다. 여기서는 출력 포맷이 XML인\nAPI를 이용합니다.\n메서드\n인증\n요청 URL\n출력 포맷\nGET\n-\nhttps://openapi.naver.com/v1/search/news.xml\nXML\nGET\n-\nhttps://openapi.naver.com/v1/search/news.json\nJSON\n요청 변수 (request parameter)\n요청 변수\n타입\n필수여부\n기본값\n설명\nquery\nstring\nY\n-\n검색을 원하는 문자열로서 UTF-8로 인코딩\ndisplay\ninteger\nN\n10(기본값), 100(최대)\n검색 결과 출력 건수 지정\nstart\ninteger\nN\n1(기본값), 1000(최대)\n검색 시작 위치로 최대 1000까지 가능\nsort\nstring\nN\nsim, date(기본값)\n정렬 옵션: sim (유사도순), date (날짜순)\n출력 결과\n필드\n타입\n설명\nrss\n-\n디버그를 쉽게 하고 RSS 리더기만으로 이용할 수 있게 하기 위해 만든\nRSS 포맷의 컨테이너이며 그 외의 특별한 의미는 없다.\nchannel\n-\n검색 결과를 포함하는 컨테이너이다. 이 안에 있는 title, link,\ndescription 등의 항목은 참고용으로 무시해도 무방하다.\nlastBuildDate\ndatetime\n검색 결과를 생성한 시간이다.\ntotal\ninteger\n검색 결과 문서의 총 개수를 의미한다.\nstart\ninteger\n검색 결과 문서 중, 문서의 시작점을 의미한다.\ndisplay\ninteger\n검색된 검색 결과의 개수이다.\nitem/items\n-\nXML 포멧에서는 item 태그로, JSON 포멧에서는 items 속성으로 표현된다.\n개별 검색 결과이며 title, originallink, link, description, pubDate를\n포함한다.\ntitle\nstring\n개별 검색 결과이며, title, originallink, link, description, pubDate\n를 포함한다.\noriginallink\nstring\n검색 결과 문서의 제공 언론사 하이퍼텍스트 link를 나타낸다.\nlink\nstring\n검색 결과 문서의 제공 네이버 하이퍼텍스트 link를 나타낸다.\ndescription\nstring\n검색 결과 문서의 내용을 요약한 패시지 정보이다. 문서 전체의 내용은\nlink를 따라가면 읽을 수 있다. 패시지에서 검색어와 일치하는 부분은\n태그로 감싸져 있다.\npubDate\ndatetime\n검색 결과 문서가 네이버에 제공된 시간이다.\n준비사항\n애플리케이션 등록: 네이버 오픈 API로 개발하시려면 먼저 ‘Application-애플리케이션 등록’ 메뉴에서\n애플리케이션을 등록하셔야 합니다.\n\n\n\nFigure 1: 애플리케이션 등록 (API 이용신청) 화면\n\n\n\n클라이언트 ID와 secret 확인: ‘내\n애플리케이션’에서 등록한 애플리케이션을 선택하면 Client ID와 Client\nSecret 값을 확인할 수 있습니다.\n\n\n\nFigure 2: 애플리케이션 정보 화면\n\n\n\n이 화면은 중요한 정보를 보여줍니다. 하루에 검색 API 호출이\n25000회로 제한되어 있습니다.\n\n\n\n\n주의\n\n클라이언트 아이디(Client ID)와  클라이언트 보안키(Client Secret)는 개인 사용자에게 발급된 정보이므로 반드시 보안에 주의해야 합니다. 타인에게 공개 및 공유하면 안된 중요한 정보이므로 사용에 주의해야 합니다.\n\n\n네이버 뉴스 검색 프로그램\n개발\n요청 URL 생성\nXML 출력 포맷을 사용하기 때문에 다음 요청 URL을 사용합니다.\nhttps://openapi.naver.com/v1/search/news.xml\n검색 질의어인 query는 UTF-8로 인코딩해야 하기 때문에\nenc2utf8()와 URLencode()을 사용합니다.\nGET 방식의 호출 URL이기 때문에 요청변수 영역을 ?로\n구분하고, 요청 변수들은 &로 구분합니다.\n\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n\n\nAPI 호출\nGET으로 호출할 때 HTTP Header에\n애플리케이션 등록 시 발급받은 Client ID와\nClient Secret 값을 같이 전송해야 합니다. 그러므로\nhttr 패키지를 사용합니다.\n\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n\n\nXML 파싱\n키워드로 검색된 뉴스의 건수를 가져옵니다. 아마도 많은 경우는 대체로\n많은 건수의 뉴스가 검색될 것입니다.\n검색 결과 문서의 총 개수를 의미하는 total 노드를\n가져다가 정수로 변환합니다.\n\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n\n\nXML 포멧에서는 item 태그로 개별 검색 결과를 반환합니다. 역시\ngetNodeSet()로 item 노드를 가져다 조작합니다.\nxmlToDataFrame()가 이들 개별 결과들을 데이터 프레임\n객체로 변환합니다.\n그리고 다음과 같은 데이터 변환을 수행합니다.\npubDate:\n날짜-시간을 표현하는 POSIXct 객체로 변환\n\ntitle:\nHTML 태그 들을 제거한 텍스트 생성하여,\ntitle_text 변수 파생\n\ndescription:\nHTML 태그 들을 제거한 텍스트 생성하여,\ndescription_text 변수 파생\n\n\n\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n\n\n\n다건 처리 로직\n요청 변수의 display는 API 호출에서 가져올 결과의\n건수입니다. 한번 호출에 최대 100건까지 가져올 수 있습니다. 그러므로 검색\n결과가 100건이 넘는 경우에는 여러번 호출을 통해서 해당하는 모든 건을\n가져올 수 있습니다.\n이 경우 검색 시작 위치인 start로 분할해서 가져올\n페이지 번호를 지정할 수 있습니다. 만약 100건을 가져왔다면 다음 호출의\nstart는 101이어야 합니다.\nstart의 최대값은 1000으로 제한되어 있습니다. 그러므로 API로 가져올 수\n있는 뉴스의 개별 결과는 100,000건입니다.\nMax(start) * Max(display) = 1000 * 100 = 100,000\n\n\n\n\n주의\n\nR은 눈사람을 만드는 것처럼 데이터를 키워나가면 안됩니다.\n\nrbind() 함수를 이용해서 API를 순차적으로 호출하면서 데이터 프레임에 결과를 붙여나가면 안됩니다. R 데이터 프레임에 관측치를 붙여나가면서 데이터를 크게 불리는 작업은 치명적인 성능 감소를 가져옵니다.\n\n\n다음은 chunk 사이즈보다 큰 다건의 검색 결과 처리를 위한\n로직입니다.\npurrr 패키지의 map_df()의 프로그래밍 함수를\n이용해서, 여러 번 API를 호출합니다. 이 로직은 주의에서\n언급한 방법을 회피하는 로직입니다.\n\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n\n\n\n함수의 완성\n이상의 로직을 통합해서 네이버 뉴스를 검색하는 함수를 다음과 같이\n정의하였습니다.\n\n\nsearch_naver <- function(query = NULL, chunk = 100, chunk_no = 1,\n                         sort = c(\"date\", \"sim\"), do_done = FALSE,\n                         max_record = 1000L, client_id = NULL,\n                         client_secret = NULL, verbose = TRUE) {\n  if (is.null(query)) {\n    stop(\"검색 키워드인 query를 입력하지 않았습니다.\")\n  }\n\n  if (chunk < 1 & chunk > 100) {\n    stop(\"chunk 요청 변수값이 허용 범위(1~100)인지 확인해 보세요.\")\n  }\n\n  if (chunk_no < 1 & chunk_no > 100) {\n    stop(\"chunk_no 요청 변수값이 허용 범위(1~1000)인지 확인해 보세요.\")\n  }\n\n  sort <- match.arg(sort)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n  }\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  if (verbose) {\n    glue::glue(\"* 검색된 총 기사 건수는 {total_count}건입니다.\\n\\n\") %>%\n      cat()\n\n    glue::glue(\"  - ({chunk}/{min(total_count, max_record)})건 호출을 진행합니다.\\n\\n\") %>%\n      cat()\n  }\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n함수의 호출\n다음은 불평등이라는 단어가 포함된 네이버 뉴스를 검색하는 예제입니다.\n실행하면 100건의 결과를 가져옵니다.\n\n\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n\n\n\n다음은 불평등이라는 단어가 포함된 네이버 뉴스를 검색하는 예제입니다.\n총 3000건의 결과를 가져옵니다. 그러므로 함수 내부에서 30번의 API 호출이\n이루어집니다.\n\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 3000\n)\n\n\n\n\n출처: https://ko.wikipedia.org/wiki/오픈_API↩︎\n",
      "last_modified": "2022-07-08T08:19:10+09:00"
    },
    {
      "path": "reactivity.html",
      "title": "반응 출력",
      "description": "반응 출력을 이해합니다. **랜더링 함수**의 종류와 기능도 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n반응형 출력을 아시나요?\n출력 위젯\nUI에 출력 위젯 추가하기\n\n렌더링 함수\n렌더링 함수로 결과\n반환하기\n\n\ntutorial\n반응 출력 완성하기\ntutorial\ntutorial 페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n의도를 파악하자마자 바로 전달합니다.\n반응출력이라 하지요.\n\n어렵지 않습니다. 유저 인터페이스를 통한 커뮤니케이션에서 화자인 의도에 대해서 그저 어떤 방식으로 반응(랜더링)할지 정하면 됩니다.\n\n\n반응형 출력을 아시나요?\n“반응형 출력(reactive output)은 사용자가 입력 위젯의 값을\n변경하면, 이에 반응, 응답하여 출력을 자동으로 만들어주는 것을\n의미합니다.”\n일반적인 웹 어플리케이션은 사용자가 입력 위젯의 값을 변경한 후,\n“확인”, “실행” 등의 버튼을 누를 때 출력이 발생하지만, Shiny는 기본적으로\n반응형 출력으로 결과를 반환합니다.\n출력 위젯\n출력 위젯의 이름의 접미사는 “Output”로 계산된 결과나 시각화 결과를\n사용자에게 보여주는 기능을 수행합니다.\nshiny 패키지의 출력 위젯은 같습니다.\n\n\nlibrary(shiny)\n\nls(pos = \"package:shiny\", pattern = \"Output$\")\n\n\n[1] \"dataTableOutput\"          \"htmlOutput\"              \n[3] \"imageOutput\"              \"plotOutput\"              \n[5] \"snapshotPreprocessOutput\" \"tableOutput\"             \n[7] \"textOutput\"               \"uiOutput\"                \n[9] \"verbatimTextOutput\"      \n\nUI에 출력 위젯 추가하기\n“selected_var”라는 아이디로 출력 위젯 textOutput을 UI에\n추가합니다.\n\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n\n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = c(\"Percent White\", \n                              \"Percent Black\",\n                              \"Percent Hispanic\", \n                              \"Percent Asian\"),\n                  selected = \"Percent White\"),\n\n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n\n    mainPanel(\n      textOutput(\"selected_var\")\n    )\n  )\n)\n\n\n\n렌더링 함수\n렌더링 함수 이름의 접두사는 “render”로 입력 위젯의 값이 변경되면\n반응하여 계산 결과를 출력 위젯에 랜더링합니다.\nshiny 패키지의 렌더링 함수는 다음과 같습니다.\n\n\nls(pos = \"package:shiny\", pattern = \"^render\")\n\n\n[1] \"renderCachedPlot\" \"renderDataTable\"  \"renderImage\"     \n[4] \"renderPlot\"       \"renderPrint\"      \"renderTable\"     \n[7] \"renderText\"       \"renderUI\"        \n\n렌더링 함수\n생성 객체\n내용\nrenderDataTable\nDataTable\n데이터 테이블\nrenderImage\n이미지\n이미지 파일 등\nrenderPlot\n플롯\n플롯 결과\nrenderPrint\n텍스트 출력\n모든 출력\nrenderTable\n테이블 구조 객체\ndata frame, matrix 등\nrenderText\n텍스트 출력\n텍스트 출력\nrenderUI\n사용저 정의 UI\n기존 위젯으로 사용자가 정의한 위젯\n렌더링 함수로 결과 반환하기\n다음 예제는 렌더링 함수인 renderText로 아이디가 “selected_var”인 출력\n위젯에 “You have selected this”라는 텍스트를 렌더링(출력)합니다.\n그러나 이것은 반응 출력이 아닙니다.\n\n\nserver <- function(input, output) {\n  output$selected_var <- renderText({ \n    \"You have selected this\"\n  })\n}\n\n\n\n다음 예제는 렌더링 함수인 renderText로 아이디가 “selected_var”인 출력\n위젯에 “You have selected this”라는 텍스트와 아이디가 “var”인 입력\n위젯의 값을 붙여서 렌더링(출력)합니다.\n이것은 반응 출력이 입니다. 렌더링 함수에 포함된 입력 위젯인 “var”의\n값이 변경될 때마다 renderText 함수가 반응하여 계산된 결과를 출력 위젯인\n“selected_var”에 렌더링합니다.\ninput$var는 아이디가 “var”인 입력 위젯을 의미하고,\noutput$selected_var는 아이디가 “selected_var”인 출력 위젯을\n의미합니다.\n\n\nserver <- function(input, output) {\n  output$selected_var <- renderText({ \n    paste(\"You have selected\", input$var)\n  })\n}\n\n\n\ntutorial\n반응 출력 완성하기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해\n보세요. 완성된 반응 출력의 기능을 확인할 수 있습니다.\n여러분은 server 파트를 완성하였습니다.\n\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n\n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = c(\"Percent White\", \n                              \"Percent Black\",\n                              \"Percent Hispanic\", \n                              \"Percent Asian\"),\n                  selected = \"Percent White\"),\n\n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n\n    mainPanel(\n      textOutput(\"selected_var\"),\n      textOutput(\"min_max\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n\n  output$selected_var <- renderText({ \n    paste(\"You have selected\", input$var)\n  })\n\n  output$min_max <- renderText({ \n    paste(\"You have chosen a range that goes from\",\n          input$range[1], \"to\", input$range[2])\n  })\n\n}\n\nshinyApp(ui, server)\n\n\n\ntutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 반응 출력을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson4/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, 또다른 반응 출력을 경험해 보세요.\n\n\nshiny::runExample(\"03_reactivity\")\n\n\n\n\n\n\n",
      "last_modified": "2022-07-08T08:19:11+09:00"
    },
    {
      "path": "shiny_resources.html",
      "title": "학습 리소스",
      "description": "**수집데이터 분석** 애플리케이션 개발을 위한 Shiny, HTML, CSS 등에 대한 학습 리소스  \n",
      "author": [],
      "contents": "\n\nContents\nShiny 학습과 개발을 위한\n리소스\nShiny 학습을 위한\n리소스\n초보자를 위한 웹 개발\n학습 리소스\nShiny 개발을 위한\n리소스\n\n\nShiny 학습과 개발을 위한\n리소스\nShiny 학습을 위한 리소스\nShiny 홈페이지 :\nhttps://shiny.rstudio.com/\n초급자 필수 사이트\n\nhtmltools 패키지 홈페이지 :\nhttps://rstudio.github.io/htmltools/\nshiny 앱에 html tags를 포함하는 기능\n\nshinydashboard 홈페이지 :\nhttps://rstudio.github.io/shinydashboard/\n초급자 필수 사이트\n\nMastering Shiny :\nhttps://mastering-shiny.org/\n중급자 이상\n\nBootstrap :\nhttps://getbootstrap.com/\n부트스트랩은 웹사이트를 쉽게 만들 수 있게 도와주는 HTML, CSS,\nJavaScript 프레임워크\nShiny는 내부적으로 Bootstrap와 인터페이스하여 반응형 앱을 구현하는\n개발 도구\n\n초보자를 위한 웹 개발 학습\n리소스\nHTML 홈페이지 :\nhttp://tcpschool.com/html/intro\nHTML(HyperText Markup Language)은 웹페이지에 내용을 기술하고\n정의하는 데 사용\n\nCSS 홈페이지 :\nhttp://tcpschool.com/css/intro\nCSS(Cascading Style Sheets)는 웹페이지 콘텐츠의 모양이나 표현을\n기술하는 데 사용\n\nJavaScript 홈페이지 :\nhttp://tcpschool.com/javascript/intro\nCSS(Cascading Style Sheets)는 웹페이지 콘텐츠 개발에 사용되는\n스크립트 프로그래밍 언어\n\nShiny 개발을 위한 리소스\nFont Awesome :\nhttps://fontawesome.com/\n앱에 사용할 아이콘 선택을 위한 정보\n\n",
      "last_modified": "2022-07-08T08:19:12+09:00"
    },
    {
      "path": "slide.html",
      "title": "Shiny로 네이버 뉴스 검색하기",
      "description": "koscrap 패키지로 Naver 뉴스를 스크랩하고, 간단한 텍스트 분석을 수행합니다. \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\n발표 슬라이드\n\n발표 슬라이드\n주제:\nShiny로 네이버 뉴스 검색하기\n\n발표 문서:\nHTML5 문서 (created xaringan in R)\n슬라이드\n\n",
      "last_modified": "2022-07-08T08:19:14+09:00"
    },
    {
      "path": "userinterface.html",
      "title": "사용자 인터페이스 만들기",
      "description": "사용자 인터페이스(UI)를 이해합니다. **page**, **layout**, **panel**을 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-07-09",
      "contents": "\n\nContents\nShiny 사용자 인터페이스\nShiny 앱 Skeleton\n페이지\nshiny 페이지\nshinydashboard 페이지\n\n레이아웃과 패널\n레이아웃\n패널\n레이아웃과 패널의 배치\n예제\n\nHTML 태그\nHTML 태그를 만드는 함수\nHTML 태그를 사용 예제\n\n\ntutorial\nUI 뼈대 만들기 tutorial\nShiny 공식 tutorial\n페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n사용자 인터페이스는\n사용자와 컴퓨터를 연결해주는 메신저입니다.\n사용자의 의도를 Shiny에게 전달하는\n의도 파악\n과 R의 수행결과를 Shiny를 통해\n내용의 전달\n을 도와줍니다.\n\n사용자 인터페이스를 이해하는 것은 훌륭한 메신저가 되기 위한 여정입니다. 자, 얼른 일어나세요.\n\n\nShiny 사용자 인터페이스\nShiny 앱 Skeleton\n\n\nlibrary(shiny)\n\n# Define UI ----\nui <- fluidPage(\n\n)\n\n# Define server logic ----\nserver <- function(input, output) {\n\n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\n페이지\nShiny 앱의 UI는 하나의 Page로 구성됩니다. 즉,\n페이지(page)에 여러 개의 위젯을 배치하여 앱을 구성합니다. 이\nSkeleton에서는 fluidPage를 사용하였군요.\n\n페이지는 화가가 그림을 그릴 캔버스라고 이해하면 쉽습니다. 화가가\n캔버스에 여러 가지 과일과 꽃 등을 배치하여 정물화를 그리거나, 나무, 산,\n강 등을 적절하게 배치하여 풍경화를 그리는 것처럼 Shiny는 페이지에 위젯을\n적절하게 배치하여 앱을 개발하는 것입니다.\n\nshiny 페이지\n다음 이미지는 앞에서 실행해 보았던 예제에서 fluidPage로 정의한\nUI입니다.\nfluidPage로 정의한 UI그리고 shiny 패키지는 다음과 같은 몇 개의 페이지 함수를 포함하고\n있습니다.\n\n\nlibrary(magrittr)\nlibrary(shiny)\n\nls(pos = \"package:shiny\", pattern = \"Page$\") %>% \n  setdiff(\n    ls(pos = \"package:shiny\", pattern = \"^update\")\n  )\n\n\n[1] \"basicPage\"     \"bootstrapPage\" \"fillPage\"      \"fixedPage\"    \n[5] \"fluidPage\"     \"navbarPage\"   \n\n\n유화를 그리는 화가는 캔버스를 준비하지만, 산수화를 그리는 화가는\n화선지를 준비하고, 초등학교 미술시간에는 크레파스와 켄트지를\n준비하겠지요. 용도에 따라 몇 개의 페이지를 준비해 놓은 것입니다.\n\nshinydashboard 페이지\n다음은 shiny로 대시보드를 구현할 때 사용하는 shinydashboard 패키지의\ndashboardPage로 정의한 UI입니다.\ndashboardPageshinydashboard 패키지는 dashboardPage라는 단 하나의 페이지만\n제공합니다.\n\n\nlibrary(shinydashboard)\n\nls(pos = \"package:shinydashboard\", pattern = \"Page$\")\n\n\n[1] \"dashboardPage\"\n\n현재 BitStat는 shinydashboard 패키지를 확장한 shinydashboardPlus\n패키지의 dashboardPage로 페이지를 구성하고 있습니다.\n레이아웃과 패널\n페이지에 위젯을 보기 좋게 배치하기 위해서 Shiny는 레이아웃(layout)과\n패널(panel)을 제공합니다. 레이아웃은 페이지를 가상으로 구획하는\n구도이며, 패널은 위젯을 그룹핑하여 패치할 공간을 의미합니다.\n\n화가는 캔버스를 가상으로 나누는 구도를 잡고 사물을 그리는 것처럼\nShiny는 레이아웃으로 구도를 잡고, 패널을 적당하게 배치한 후 패널 안에\n비로소 위젯을 채워나갑니다. 즉, 레이아웃과 패널을 적당히 섞어서 앱의\n모양(UI)을 정의합니다.\n\n레이아웃\nshiny 패키지는 몇 개의 레이아웃을 제공하는데 앞의 예제처럼\nsidebarLayout이 일반적으로 사용됩니다.\n\n\nls(pos = \"package:shiny\", pattern = \"Layout$\") \n\n\n[1] \"flowLayout\"     \"sidebarLayout\"  \"splitLayout\"   \n[4] \"verticalLayout\"\n\n패널\nshiny 패키지는 몇 개의 패널을 제공하는데 앞의 예제에서는 titlePanel,\nsidebarPanel, mainPanel이 사용되었습니다.\n\n\nls(pos = \"package:shiny\", pattern = \"Panel$\") %>% \n  setdiff(\n    ls(pos = \"package:shiny\", pattern = \"^update\")\n  )\n\n\n [1] \"absolutePanel\"    \"conditionalPanel\" \"fixedPanel\"      \n [4] \"headerPanel\"      \"inputPanel\"       \"mainPanel\"       \n [7] \"navlistPanel\"     \"sidebarPanel\"     \"tabPanel\"        \n[10] \"tabsetPanel\"      \"titlePanel\"       \"wellPanel\"       \n\n레이아웃과 패널의 배치 예제\n다음 예제는 히스토그램을 그리는 예제에서의 레이아웃과 패널의 배치\n방법입니다. 위젯을 포함하지 않은 상태입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"title panel\"),\n\n  sidebarLayout(\n    sidebarPanel(\"sidebar panel\"),\n    mainPanel(\"main panel\")\n  )\n)\n\n\n\n위와 같은 배치는 다음 그림과 같은 사이드 바 구도를 만들어 줍니다.\n사이드바 레이아웃sidebarLayout은 일반적으로 sidebarPanel와 mainPanel을 포함합니다.\n이것은 왼쪽에 사이드 바 패널을 만들어서 사용자의 입력을\n받는 위젯을 배치하고 오른쪽에는 사용자의 입력에 따른 결과를\n출력할 메인 패널을 배치하는 방법으로 동작합니다.\ntitlePanel은 이름처럼 앱의 타이틀을 출력할 패널입니다.\nHTML 태그\n아시다시피 Shiny 앱을 HTML로 동작하는 웹 어플리케이션을 의미합니다.\n즉, Shiny가 만들어 주는 것은 웹 어플리케이션을 구성하는 HTML, CSS,\nJavascript입니다.\nR의 htmltools 패키지는 HTML 태그를 만들어 주는 패키지입니다. shiny\n패키지가 htmltools 패키지를 이용해서 HTML 태그를 만들어 줍니다.\nHTML 태그를 만드는 함수\nh1() 함수는 첫번째 레벨의 해더를 생성하는 MTML의 <h1> 태그를\n만들어 줍니다. 글쓰기에서 장(Chapter)의 타이틀을 만들 때 사용하는\n태그입니다. 헤더(Headers)를 만들어 준다고 이해하면 쉽겠지요. 이니셜을\n따서 h, 첫번 째라서 1가 됩니다. 합치면 h1가 되겠지요. 숫자가 클수록\n글자의 크기가 작아집니다.\nh1() 함수는 다음처럼 <h1> 태그를 만들어 줍니다.\n\nh1(\"A first level header\")\n[1] <h1>A first level header<\/h1>\n\n\n그런데, 이 HTML 태그는 웹 브라우저에서 다음과 같이 출력됩니다.\n\nA first level header\n\nshiny 패키지에서 제공하는 대표적인 HTML 태그 함수는 다음과\n같습니다.\n함수\nHTML 태그\n의미\np\n<p>\n파라그래프 텍스트\nh1\n<h1>\n첫번째 헤더\nh2\n<h2>\n두번째 헤더\nh3\n<h3>\n세번째 헤더\nh4\n<h4>\n네번째 헤더\nh5\n<h5>\n다섯번째 헤더\nh6\n<h6>\n여섯번째 헤더\nbr\n<br>\n줄 바꿈\nhr\n<hr>\n수평선 긋기\nimg\n<img>\n이미지 삽입\nstrong\n<strong>\n볼드체\ndiv\n<div>\n동일 스타일의 문자 디비젼\nspan\n<span>\n동일 스타일의 문자 인라인\nHTML 태그를 사용 예제\n다음 예제는 여러 종류의 헤더를 출력하는 UI의 설계입니다. 입력 위젯은\n포함하지 않은 상태입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"My Shiny App\"),\n  sidebarLayout(\n    sidebarPanel(),\n    mainPanel(\n      h1(\"First level title\"),\n      h2(\"Second level title\"),\n      h3(\"Third level title\"),\n      h4(\"Fourth level title\"),\n      h5(\"Fifth level title\"),\n      h6(\"Sixth level title\")\n    )\n  )\n)\n\n\n\n위와 같은 배치는 다음 그림과 같은 사이드 바 구도를 만들어 줍니다.\n사이드바 레이아웃tutorial\ntutorial에서는 UI 뼈대를 만들기 위해서 fluidPage, sidebarLayout,\nmainPanel, tabsetPanel을 사용합니다.\nUI 뼈대 만들기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해\n보세요. 앞에서 다룬 사이드바 레이아웃 그림과 같은 앱이\n출력됩니다.\n\n\nlibrary(shiny)\n\n# Define UI ----\nui <- fluidPage(\n  titlePanel(\"title panel\"),\n\n  sidebarLayout(position = \"right\",\n                sidebarPanel(\"sidebar panel\"),\n                mainPanel(\"main panel\")\n  )\n)\n\n# Define server logic ----\nserver <- function(input, output) {\n\n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 사용자 인터페이스를 구축하는\n방법을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson2/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, tabsetPanel의 기능을 이해하세요. tabsetPanel은\n탭 기능으로 여러 출력 위젯을 선택적으로 한 화면에 표현해 줍니다.\n\n\nshiny::runExample(\"06_tabsets\")\n\n\n\n\n\n\n",
      "last_modified": "2022-07-08T08:19:15+09:00"
    }
  ],
  "collections": []
}
